[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n코드1 + 1\n\n[1] 2"
  },
  {
    "objectID": "chatGPT_setup.html",
    "href": "chatGPT_setup.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "OpenAI Playground\n\n챗GPT\n챗GPT API"
  },
  {
    "objectID": "chatGPT_setup.html#통합개발환경",
    "href": "chatGPT_setup.html#통합개발환경",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 통합개발환경",
    "text": "2.1 통합개발환경\n\nVisual Studio Code: https://code.visualstudio.com/download\n\nRStudio: https://posit.co/download/rstudio-desktop/\n\nJupyter: https://jupyter.org/install"
  },
  {
    "objectID": "chatGPT_setup.html#버젼제어",
    "href": "chatGPT_setup.html#버젼제어",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 버젼제어",
    "text": "2.2 버젼제어\n\nGit for Windows: https://gitforwindows.org/"
  },
  {
    "objectID": "chatGPT_setup.html#프로그래밍-언어",
    "href": "chatGPT_setup.html#프로그래밍-언어",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 프로그래밍 언어",
    "text": "2.3 프로그래밍 언어\n\nR: https://cran.r-project.org/bin/windows/base/\n\n파이썬: https://www.python.org/downloads/"
  },
  {
    "objectID": "chatGPT_setup.html#문서저작",
    "href": "chatGPT_setup.html#문서저작",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.4 문서저작",
    "text": "2.4 문서저작\n\nQuarto: https://quarto.org/docs/download/"
  },
  {
    "objectID": "chatGPT_setup.html#sql",
    "href": "chatGPT_setup.html#sql",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.5 SQL",
    "text": "2.5 SQL\n\nSqlite3: https://www.sqlite.org/index.html\n\nDuckDB: https://duckdb.org/\n\nPostgreSQL: https://www.postgresql.org/download/"
  },
  {
    "objectID": "chatGPT_setup.html#딥러닝",
    "href": "chatGPT_setup.html#딥러닝",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.6 딥러닝",
    "text": "2.6 딥러닝\n\n텐서플로우: https://www.tensorflow.org/install\n\n파이토치: https://pytorch.org/\n\nHuggingface: https://huggingface.co/"
  },
  {
    "objectID": "chatGPT_setup.html#챗gpt-1",
    "href": "chatGPT_setup.html#챗gpt-1",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.1 챗GPT",
    "text": "4.1 챗GPT\n\n챗GPT : https://r2bit.com/chatGPT/\n\n챗GPT 유닉스 쉘 : https://github.com/bit2r/gpt-shell"
  },
  {
    "objectID": "chatGPT_setup.html#전자책",
    "href": "chatGPT_setup.html#전자책",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.2 전자책",
    "text": "4.2 전자책\n\n\nBitBook: https://r2bit.com/book"
  },
  {
    "objectID": "chatGPT_setup.html#블로그",
    "href": "chatGPT_setup.html#블로그",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.3 블로그",
    "text": "4.3 블로그\n\n데이터 과학: https://statkclee.github.io/data-science/\n\n시각화: https://statkclee.github.io/viz/\n\n문서제작: http://statkclee.github.io/comp_document/\n\n쿼토(Quarto): https://r2bit.com/quarto/\n\n파워포인트(PPT): https://r2bit.com/bitSlide/\n\n웹슬라이드(Xaringan): http://statkclee.github.io/ds-authoring/\n\n\n\n데이터 과학 제품: http://statkclee.github.io/data-product/\n\n딥러닝 기본기 : https://statkclee.github.io/united-states/\n\n…"
  },
  {
    "objectID": "chatGPT_setup_R.html",
    "href": "chatGPT_setup_R.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "R 다운로드 웹사이트에서 운영체제에 맞는 R 엔진을 다운로드 받아 설치한다."
  },
  {
    "objectID": "chatGPT_setup_R.html#로컬-글꼴---no-font-name",
    "href": "chatGPT_setup_R.html#로컬-글꼴---no-font-name",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n5.1 로컬 글꼴 - “No Font Name”",
    "text": "5.1 로컬 글꼴 - “No Font Name”\n로컬 컴퓨터에 설치를 했으나 제대로 “No Font Name” 이슈가 있는 경우 다음과 같이 해결한다. 즉, Rttf2pt1 이전 버전을 사용하여 운영체제에 등록된 폰트를 R에서 사용할 수 있는 폰트로 등록한다. 그리고 나서, loadfonts() 함수를 사용해서 글꼴을 시각화에서 사용할 수 있도록 조치를 취한다.\n문제해결: How can I resolve the “No Font Name” issue when importing fonts into R using extrafont?, Dataholic, “추가 폰트 사용하기”"
  },
  {
    "objectID": "chatGPT_setup_bash.html",
    "href": "chatGPT_setup_bash.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "윈도우 환경에서 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구.\n\nGit for Windows: https://gitforwindows.org/\n\n\n윈도우 10/11에서 WSL(Windows Subsystem Linux)을 설치하여 윈도우에서 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구\n\nWindows Subsystem for Linux (WSL) : https://learn.microsoft.com/en-us/windows/wsl/install\n\n\n격리 가상화 기술을 사용하여 운영체제에 독립적으로 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구\n\n도커: https://www.docker.com/\n\n\n명령라인 데이터 분석 작업을 수행하기 위한 환경을 개별적으로 구축하기 보다 이미 구축된 도커 환경을 가져와서 준비한다. (janssens2021data?)\n\n\n도커를 다운로드 받아 설치한다.\n\n도커허브에서 도커이미지를 받아온다.\n\ndatasciencetoolbox/dsatcl2e\n\n\n도커를 실행시키고 로컬 디렉토리와 도커 컨테이너 디렉토리를 일치시킨다.\n\n\n\n도커 로컬 디렉토리와 컨테이너 디렉토리 마운트 작업\n\n$ docker pull datasciencetoolbox/dsatcl2e \n$ docker run --rm -it datasciencetoolbox/dsatcl2e\n$ docker run --rm -it -v \"$(pwd)\":/home/dst/data datasciencetoolbox/dsatcl2e\n\n데이터 과학에 특화된 클라우드 서비스를 사용하여 운영체제에 독립적으로 유닉스/리눅스 쉘 명령어는 물론 데이터 과학에 필요한 다양한 기능을 지원하는 서비스\n\nPosit Cloud (formerly RStudio Cloud): https://posit.cloud/\n\n빛에듀: http://bit-edu.iptime.org/rstudio/"
  },
  {
    "objectID": "chatGPT_setup_bash.html#git-bash",
    "href": "chatGPT_setup_bash.html#git-bash",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "윈도우 환경에서 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구.\n\nGit for Windows: https://gitforwindows.org/"
  },
  {
    "objectID": "chatGPT_setup_bash.html#wsl",
    "href": "chatGPT_setup_bash.html#wsl",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "윈도우 10/11에서 WSL(Windows Subsystem Linux)을 설치하여 윈도우에서 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구\n\nWindows Subsystem for Linux (WSL) : https://learn.microsoft.com/en-us/windows/wsl/install"
  },
  {
    "objectID": "chatGPT_setup_bash.html#도커",
    "href": "chatGPT_setup_bash.html#도커",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "격리 가상화 기술을 사용하여 운영체제에 독립적으로 유닉스/리눅스 쉘 명령어를 사용하여 컴퓨터를 조작할 수 있도록 해주는 도구\n\n도커: https://www.docker.com/\n\n\n명령라인 데이터 분석 작업을 수행하기 위한 환경을 개별적으로 구축하기 보다 이미 구축된 도커 환경을 가져와서 준비한다. (janssens2021data?)\n\n\n도커를 다운로드 받아 설치한다.\n\n도커허브에서 도커이미지를 받아온다.\n\ndatasciencetoolbox/dsatcl2e\n\n\n도커를 실행시키고 로컬 디렉토리와 도커 컨테이너 디렉토리를 일치시킨다.\n\n\n\n도커 로컬 디렉토리와 컨테이너 디렉토리 마운트 작업\n\n$ docker pull datasciencetoolbox/dsatcl2e \n$ docker run --rm -it datasciencetoolbox/dsatcl2e\n$ docker run --rm -it -v \"$(pwd)\":/home/dst/data datasciencetoolbox/dsatcl2e"
  },
  {
    "objectID": "chatGPT_setup_bash.html#클라우드",
    "href": "chatGPT_setup_bash.html#클라우드",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "데이터 과학에 특화된 클라우드 서비스를 사용하여 운영체제에 독립적으로 유닉스/리눅스 쉘 명령어는 물론 데이터 과학에 필요한 다양한 기능을 지원하는 서비스\n\nPosit Cloud (formerly RStudio Cloud): https://posit.cloud/\n\n빛에듀: http://bit-edu.iptime.org/rstudio/"
  },
  {
    "objectID": "chatGPT_setup_bash.html#최신-배쉬-설치",
    "href": "chatGPT_setup_bash.html#최신-배쉬-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 최신 배쉬 설치",
    "text": "2.1 최신 배쉬 설치\n명령라인 데이터분석을 위해서는 먼저 다음과 같이 다양한 쉘 중에서 특정 쉘(bash)을 지정하고 이를 기본 쉘로 설정한다. 왜냐하면 경우에 따라서 쉘 명령어가 동작하지 않는 경우가 있기 때문이다.\n$ brew install bash\n$ which -a bash\n$ sudo chsh -s /usr/local/bin/bash\n$ bash --version\nGNU bash, version 5.2.15(1)-release (x86_64-apple-darwin21.6.0)\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\n\nThis is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n\n\n\n\n\nzsh → bash 기본 쉘 설정\n\n\n\n맥에서 zsh가 기본 쉘로 설정된 경우 이를 bash로 상기 명령어로 지정한다.\n$ sudo chsh -s /usr/local/bin/bash"
  },
  {
    "objectID": "chatGPT_setup_bash.html#배쉬툴-설치",
    "href": "chatGPT_setup_bash.html#배쉬툴-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 배쉬툴 설치",
    "text": "2.2 배쉬툴 설치\n배쉬를 설정하고 기본 쉘로 설정한 후에 생산성 향상과 즐거운 데이터분석업무를 위해서 필요한 추가 도구를 설정한다. ble.sh와 bash-it이 가장 많이 사용되고 있어 둘 중에서 마음에 드는 것을 설치한다.\n\n\n\n\n배쉬 설치 후 첫 실행화면\n\n\n\n배쉬\n\n\n그림 1: 배쉬 도구 설치 전후 비교\n\n\nbash-it을 다운로드 받아 다음 명령어로 설치한다.\n$ git clone --depth=1 https://github.com/Bash-it/bash-it.git ~/.bash_it\n$ ~/.bash_it/install.sh\n$ source ~/.bash_profile"
  },
  {
    "objectID": "chatGPT_setup_python.html",
    "href": "chatGPT_setup_python.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "참조: Riddhiman (Apr 19, 2022), “Getting started with Python using R and reticulate”, R’tichoke\n\nR/쿼토 환경에서 파이썬을 사용하는 가장 간단한 방법은 미니콘다를 사용하는 방식이다. 미니콘다(miniconda)는 작고 가볍기 때문에 아나콘다를 기본 기능을 사용할 수 있는 장점도 있다. 추후 필요한 기능에 필요한 패키지를 설치하여 사용한다.\nR에서 이를 가능하게 하는 방식이 reticulate 패키지를 설치한 후 전체 과정을 단순화시킬 수 있다.\n\n미니콘다가 다른 이슈없이 설치되었다면 conda_list() 함수를 사용해서 `r-reticulate``\n\n\nuse_python(): 파이썬이 설치된 경로.\n\nuse_virtualenv(): 파이썬 가상환경(virtualenv)이 설치된 경로.\n\nuse_condaenv(): 콘다 환경이 설치된 경로.\n\n            name                                                           python\n1   r-reticulate                     C:\\\\miniconda\\\\envs\\\\r-reticulate/python.exe\n6      miniconda                                         C:\\\\miniconda/python.exe\n콘다환경에서 가상환경을 구축한다. 가상환경의 명칭을 pyenv로 특정한다.\n\nreticulate 패키지에 포함된 py_install() 함수로 기계학습과 데이터 과학에 필요한 패키지를 설치한다. 추후 .ipynb 쥬피터 노트북 파이썬 결과물을 쿼토에서 컴파일하는데 필요한 jupyter 패키지도 설치한다."
  },
  {
    "objectID": "chatGPT_setup_python.html#미니콘다-설치",
    "href": "chatGPT_setup_python.html#미니콘다-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "R/쿼토 환경에서 파이썬을 사용하는 가장 간단한 방법은 미니콘다를 사용하는 방식이다. 미니콘다(miniconda)는 작고 가볍기 때문에 아나콘다를 기본 기능을 사용할 수 있는 장점도 있다. 추후 필요한 기능에 필요한 패키지를 설치하여 사용한다.\nR에서 이를 가능하게 하는 방식이 reticulate 패키지를 설치한 후 전체 과정을 단순화시킬 수 있다."
  },
  {
    "objectID": "chatGPT_setup_python.html#가상환경",
    "href": "chatGPT_setup_python.html#가상환경",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "미니콘다가 다른 이슈없이 설치되었다면 conda_list() 함수를 사용해서 `r-reticulate``\n\n\nuse_python(): 파이썬이 설치된 경로.\n\nuse_virtualenv(): 파이썬 가상환경(virtualenv)이 설치된 경로.\n\nuse_condaenv(): 콘다 환경이 설치된 경로.\n\n            name                                                           python\n1   r-reticulate                     C:\\\\miniconda\\\\envs\\\\r-reticulate/python.exe\n6      miniconda                                         C:\\\\miniconda/python.exe\n콘다환경에서 가상환경을 구축한다. 가상환경의 명칭을 pyenv로 특정한다."
  },
  {
    "objectID": "chatGPT_setup_python.html#패키지-설치",
    "href": "chatGPT_setup_python.html#패키지-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "reticulate 패키지에 포함된 py_install() 함수로 기계학습과 데이터 과학에 필요한 패키지를 설치한다. 추후 .ipynb 쥬피터 노트북 파이썬 결과물을 쿼토에서 컴파일하는데 필요한 jupyter 패키지도 설치한다."
  },
  {
    "objectID": "chatGPT_setup_python.html#파이썬-환경구축-1",
    "href": "chatGPT_setup_python.html#파이썬-환경구축-1",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 파이썬 환경구축",
    "text": "2.1 파이썬 환경구축\n콘다환경을 구축하여 파이썬 데이터 과학 프로그램을 실행시킬 수 있는 환경을 구축한다."
  },
  {
    "objectID": "chatGPT_setup_python.html#시각화",
    "href": "chatGPT_setup_python.html#시각화",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 시각화",
    "text": "2.2 시각화\n고양이와 개에 대한 피쳐(Feature)를 바탕으로 고양이와 개를 분류하는 분류기계학습 모형을 개발해보자. 먼저, 기계학습을 위한 훈련 시험 데이터를 준비하고 시각화를 한다."
  },
  {
    "objectID": "chatGPT_setup_python.html#분류모형",
    "href": "chatGPT_setup_python.html#분류모형",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 분류모형",
    "text": "2.3 분류모형\n다양한 기계학습모형이 존재하지만 먼저 KNN 분류모형을 적합시켜 고양이와 개 분류 기계학습모형을 개발한다.\n\n\n\n\n\nKNeighborsClassifier()\nIn a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\n\n\nKNeighborsClassifierKNeighborsClassifier()"
  },
  {
    "objectID": "chatGPT_setup_python.html#분류모형-성능",
    "href": "chatGPT_setup_python.html#분류모형-성능",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.4 분류모형 성능",
    "text": "2.4 분류모형 성능\n데이터에 적합시킨 모형이 얼마나 고양이와 개를 잘 분류하는지 예측 정확도를 따져보자.\n\n#&gt; 모형 정확도   : 1.000"
  },
  {
    "objectID": "chatGPT_setup_python.html#분류모형-예측",
    "href": "chatGPT_setup_python.html#분류모형-예측",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.5 분류모형 예측",
    "text": "2.5 분류모형 예측\n실제로 기계학습모형에 사용된 적이 없는 개와 고양이 데이터를 직접 넣어 어떻게 예측하는지 확인해보자.\n\n#&gt; ['Cat']"
  },
  {
    "objectID": "chatGPT_setup_python.html#ipynb-.qmd-1",
    "href": "chatGPT_setup_python.html#ipynb-.qmd-1",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.1 .ipynb → .qmd\n",
    "text": "3.1 .ipynb → .qmd\n\n개와 고양이 분류 예측모형 개발을 파이썬 쥬피터 노트북으로 개발을 하였다면 이를 쿼토로 변환시켜 _quarto.yml 파일에 등재시킬 수 있는 .qmd 파일로 변환시킨다.\n$ quarto convert hello_world_jupyter.ipynb\nConverted to hello_world_jupyter.qmd"
  },
  {
    "objectID": "chatGPT_setup_python.html#qmd-.ipynb",
    "href": "chatGPT_setup_python.html#qmd-.ipynb",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.2 .qmd → .ipynb\n",
    "text": "3.2 .qmd → .ipynb\n\n마찬가지로 .qmd 파일을 쥬피터 .ipynb 파일로 변환시킬 경우 동일하게 quarto convert 명령어를 사용한다.\n$ quarto convert hello_world_qmd.qmd\nConverted to hello_world_qmd.ipynb"
  },
  {
    "objectID": "chatGPT_setup_sql.html",
    "href": "chatGPT_setup_sql.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "SQLite 다운로드 웹사이트에서 운영체제에 적합한 SQlite 소프트웨어를 설치한다.\n\n예를 들어, 윈도우 10 환경에서 “Precompiled Binaries for Windows” → sqlite-tools-win32-x86-3400000.zip 파일을 다운로드 받는다.\n다음으로 압축을 풀어 다음 순서로 설치를 완료하고 정상적으로 설치되었는지 확인한다.\n\n\n\n\nSQlite 다운로드\n\n\n\nSQlite 설치\n\n\n\nSqlite 환경등록\n\n\n\nSQlite 실행과 종료\n\n\n그림 1: SQlite 설치 및 헬로월드\n\n\n\n맥에서 Sqlite를 설치하는 방법은 매우 단순하다. DB Browser for SQLite 웹사이트에서 맥버전(Intell or Apple Silicon) 버전을 다운로드 받아 설치하면 된다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#윈도우즈",
    "href": "chatGPT_setup_sql.html#윈도우즈",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "예를 들어, 윈도우 10 환경에서 “Precompiled Binaries for Windows” → sqlite-tools-win32-x86-3400000.zip 파일을 다운로드 받는다.\n다음으로 압축을 풀어 다음 순서로 설치를 완료하고 정상적으로 설치되었는지 확인한다.\n\n\n\n\nSQlite 다운로드\n\n\n\nSQlite 설치\n\n\n\nSqlite 환경등록\n\n\n\nSQlite 실행과 종료\n\n\n그림 1: SQlite 설치 및 헬로월드"
  },
  {
    "objectID": "chatGPT_setup_sql.html#맥-설치",
    "href": "chatGPT_setup_sql.html#맥-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "맥에서 Sqlite를 설치하는 방법은 매우 단순하다. DB Browser for SQLite 웹사이트에서 맥버전(Intell or Apple Silicon) 버전을 다운로드 받아 설치하면 된다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#명령라인",
    "href": "chatGPT_setup_sql.html#명령라인",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.1 명령라인",
    "text": "3.1 명령라인\nSQlite가 설치되고 데이터베이스가 있다면 SQL 쿼리문을 작성하여 원하는 결과를 얻을 수 있다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#쿼리도구",
    "href": "chatGPT_setup_sql.html#쿼리도구",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.2 쿼리도구",
    "text": "3.2 쿼리도구\n동일한 사항을 DB Browser for SQLite 쿼리도구를 사용하면 직관적으로 다양한 SQL 문을 데이터베이스에 던져 원하는 결과를 얻을 수 있다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#데이터셋",
    "href": "chatGPT_setup_sql.html#데이터셋",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.1 데이터셋",
    "text": "4.1 데이터셋\nNYC Taxi Trip Data - Google Public Data 데이터셋은 구글 빅쿼리(Bigquery) 공개 데이터셋중 일부로 뉴육택시 운행 천만건을 담고 있다. 뉴욕 택시 데이터셋에 대한 자세한 정보는 캐글 웹사이트에서 확인할 수 있다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#데이터베이스",
    "href": "chatGPT_setup_sql.html#데이터베이스",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.2 데이터베이스",
    "text": "4.2 데이터베이스\nduckdb패키지를 설치하여 taxis.duckdb를 파일로 생성하고 연결을 시켜둔다.\ndata\\ 디렉토리 아래 뉴욕 택시 운행 데이터와 duckdb가 하나 파일명으로 taxis.duckdb 생성된 것이 확인된다.\n\n#&gt; data\n#&gt; ├── taxis.duckdb\n#&gt; └── 건국대_커리큘럼.xlsx"
  },
  {
    "objectID": "chatGPT_setup_sql.html#테이블-추가",
    "href": "chatGPT_setup_sql.html#테이블-추가",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.3 테이블 추가",
    "text": "4.3 테이블 추가\nduckdb 데이터베이스에 뉴욕택시 데이터셋을 테이블로 추가한다.\n[1] 8319928"
  },
  {
    "objectID": "chatGPT_setup_sql.html#테이블-확인",
    "href": "chatGPT_setup_sql.html#테이블-확인",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.4 테이블 확인",
    "text": "4.4 테이블 확인\ndbListTables() 명령어로 데이터베이스 내 테이블이 제대로 올라갔는지 확인한다.\n[1] \"trips\""
  },
  {
    "objectID": "chatGPT_setup_sql.html#db-연결-끊기",
    "href": "chatGPT_setup_sql.html#db-연결-끊기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.5 DB 연결 끊기",
    "text": "4.5 DB 연결 끊기\ncon으로 DB에 연결을 했다면 다음으로 연결을 dbDisconnect() 명령어로 연결을 해제한다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#sql-쿼리-1",
    "href": "chatGPT_setup_sql.html#sql-쿼리-1",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.6 SQL 쿼리",
    "text": "4.6 SQL 쿼리\n지금까지 작업한 사항내용을 그림으로 요약하면 다음과 같다.\n\n파일 duckDB 데이터베이스를 생성한다.\n데이터베이스에 con DB 핸들러를 통해 R/파이썬 연결을 시킨다.\nCSV 파일을 테이블로 데이터베이스에 올린다.\n정상적으로 테이블이 데이터베이스에 등록되었는지를 확인한다.\nDB 핸들러를 반납하고 연결을 해제시킨다.\n\n\n\n\n\n이제부터 본격적으로 OLAP 분석작업을 수행한다. 파일 “/data/taxis.duckdb” 데이터베이스에 DB 핸들러를 연결시킨다. 그리고 나서 분석대상 테이블이 존재하는지 dbListTables() 명령어로 확인한다.\n\n#&gt; [1] \"trips\"\n\ntictock 패키지를 통해 해당 쿼리가 수행되는데 실행된 시간을 측정한다.\n\n#&gt; 0.39 sec elapsed\n#&gt; # A tibble: 4 × 2\n#&gt;   payment_type average_fare\n#&gt;          &lt;int&gt;        &lt;dbl&gt;\n#&gt; 1            1         65.4\n#&gt; 2            2         60.9\n#&gt; 3            3         62.5\n#&gt; 4            4         67.1"
  },
  {
    "objectID": "chatGPT_setup_sql.html#sql-문",
    "href": "chatGPT_setup_sql.html#sql-문",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.7 SQL 문",
    "text": "4.7 SQL 문\ndplyr 데이터 핸들링 문법이 매우 직관적이고 사용하기 편하다. 이를 SQL문으로 변환하는 것도 단순하다. 이를 동일하게 SQL 문으로 작성하여 쿼리문을 던져 분석작업을 수행하자.\n\n#&gt; &lt;SQL&gt;\n#&gt; SELECT payment_type, AVG(fare_amount) AS average_fare\n#&gt; FROM (\n#&gt;   SELECT payment_type, fare_amount, trip_distance\n#&gt;   FROM trips\n#&gt;   WHERE (trip_distance &gt; 18.0)\n#&gt; ) q01\n#&gt; GROUP BY payment_type\n#&gt; # Source:   SQL [4 x 2]\n#&gt; # Database: DuckDB 0.6.1 [statkclee@Windows 10 x64:R 4.2.2/D:/tcs/konkuk/data/taxis.duckdb]\n#&gt;   payment_type average_fare\n#&gt;          &lt;int&gt;        &lt;dbl&gt;\n#&gt; 1            1         65.4\n#&gt; 2            2         60.9\n#&gt; 3            3         62.5\n#&gt; 4            4         67.1\n\n동일한 결과를 dbGetQuery()함수로 결과값을 얻을 수 있다.\n\n#&gt;   payment_type average_fare\n#&gt; 1            1     65.40479\n#&gt; 2            2     60.86640\n#&gt; 3            3     62.52643\n#&gt; 4            4     67.13895"
  },
  {
    "objectID": "chatGPT_setup_sql.html#dbeaver-sql-쿼리-도구",
    "href": "chatGPT_setup_sql.html#dbeaver-sql-쿼리-도구",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.8 DBeaver SQL 쿼리 도구",
    "text": "4.8 DBeaver SQL 쿼리 도구\nDBeaver Community - Free Universal Database Tool 도구를 다운로드 받고 앞서 구축한 뉴욕 택시 데이터베이스를 연결하면 동일한 결과를 얻을 수 있다.\n먼저, DBeaver Community - Free Universal Database Tool 웹사이트에서 운영체제에 맞는 SQL 쿼리 도구를 설치한다.\n\n\n\n\n그리고 나서 앞서 dbplyr show_query() 함수를 사용해서 SQL 문을 복사하여 붙여넣기 하면 해당 결과를 얻을 수 있다."
  },
  {
    "objectID": "chatGPT_setup_sql.html#파일-크기",
    "href": "chatGPT_setup_sql.html#파일-크기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n4.9 파일 크기",
    "text": "4.9 파일 크기\n뉴욕 택시 원본파일 크기를 살펴보자. 이를 위해서 fs패키지 file_info()함수를 사용해서 확인한다.\n\n#&gt; # A tibble: 1 × 3\n#&gt;   path                                         type         size\n#&gt;   &lt;fs::path&gt;                                   &lt;fct&gt; &lt;fs::bytes&gt;\n#&gt; 1 data/original_cleaned_nyc_taxi_data_2018.csv &lt;NA&gt;           NA\n\nCSV 파일을 duckDB에서 가져왔을 때 데이터베이스 크기를 살펴보자.\n\n#&gt; # A tibble: 1 × 3\n#&gt;   path              type         size\n#&gt;   &lt;fs::path&gt;        &lt;fct&gt; &lt;fs::bytes&gt;\n#&gt; 1 data/taxis.duckdb file         258M"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "챗GPT 데이터 사이언스\n  전문교육과정\n\n\n    \n\n강의주제\n      강의내용\n      수업방법\n    \n\n\n\n1 주차 - 2023-07-01\n    \n\n데이터 사이언스 언어\n챗GPT와 데이터 사이언스\n핸즈온 실습\n\n\n데이터 사이언스 언어\nTidyverse와 챗GPT\n핸즈온 실습\n\n\n데이터 사이언스 언어\n파이썬/R/SQL 그리고 API\n핸즈온 실습\n\n\n2 주차 - 2023-07-08\n    \n\n소프트웨어 카펜트리 (기본기)\n자동화: 유닉스 쉘\n핸즈온 실습\n\n\n소프트웨어 카펜트리 (기본기)\n버전제어: Git / GitHub\n핸즈온 실습\n\n\n3 주차 - 2023-07-15\n    \n\n소프트웨어 카펜트리 (기본기)\n파이썬 / R\n핸즈온 실습\n\n\n소프트웨어 카펜트리 (기본기)\n데이터베이스\n핸즈온 실습\n\n\n4 주차 - 2023-07-22\n    \n\n데이터 과학 자료구조\n숫자/범주 --&gt; 데이터프레임\n핸즈온 실습\n\n\n데이터 과학 자료구조\n날짜/공간정보/네트워크\n핸즈온 실습\n\n\n데이터 과학 자료구조\n텍스트/이미지/오디오\n핸즈온 실습\n\n\n5 주차 - 2023-07-29\n    \n\n디지털 글쓰기, 대쉬보드, API 개발\n디지털 보고서(PDF, HTML, PPT)\n핸즈온 실습\n\n\n디지털 글쓰기, 대쉬보드, API 개발\nServerless 대쉬보드, R/Python 대쉬보드\n핸즈온 실습\n\n\n디지털 글쓰기, 대쉬보드, API 개발\n기계학습 모형 API 배포\n핸즈온 실습\n\n\n- 주차 - 2023-08-05\n    \n\n휴가\n휴가\n-\n\n\n6 주차 - 2023-08-12\n    \n\n챗GPT와 오픈소스\n(오픈소스) 거대언어모형(LLM)\n핸즈온 실습\n\n\n챗GPT와 오픈소스\nWrite/Draw/Coding/Reasoning\n핸즈온 실습\n\n\n챗GPT와 오픈소스\nAI 시대 데이터 사이언스 제품개발 방법\n핸즈온 실습\n\n\n7 주차 - 2023-08-19\n    \n\nPrompt Engineering\n사용자 및 개발자를 위한 프롬프트 공학\n핸즈온 실습\n\n\nPrompt Engineering\nOpenAI API 기반 NLP 개발\n핸즈온 실습\n\n\nPrompt Engineering\nOPL(OpenAI, Pinecone, Langchain) 프레임워크\n핸즈온 실습\n\n\n8 주차 - 2023-08-26\n    \n\n챗GPT AI 앱 프로젝트\n오픈소스 LLM 기반 AI 데이터 분석 제품\n핸즈온 실습\n\n\n챗GPT AI 앱 프로젝트\n데이터 사이언스 AutoGPT\n핸즈온 실습\n\n\n챗GPT AI 앱 프로젝트\n챗GPT AI 프로젝트 발표\n핸즈온 실습"
  },
  {
    "objectID": "index.html#커리큘럼",
    "href": "index.html#커리큘럼",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "챗GPT 데이터 사이언스\n  전문교육과정\n\n\n    \n\n강의주제\n      강의내용\n      수업방법\n    \n\n\n\n1 주차 - 2023-07-01\n    \n\n데이터 사이언스 언어\n챗GPT와 데이터 사이언스\n핸즈온 실습\n\n\n데이터 사이언스 언어\nTidyverse와 챗GPT\n핸즈온 실습\n\n\n데이터 사이언스 언어\n파이썬/R/SQL 그리고 API\n핸즈온 실습\n\n\n2 주차 - 2023-07-08\n    \n\n소프트웨어 카펜트리 (기본기)\n자동화: 유닉스 쉘\n핸즈온 실습\n\n\n소프트웨어 카펜트리 (기본기)\n버전제어: Git / GitHub\n핸즈온 실습\n\n\n3 주차 - 2023-07-15\n    \n\n소프트웨어 카펜트리 (기본기)\n파이썬 / R\n핸즈온 실습\n\n\n소프트웨어 카펜트리 (기본기)\n데이터베이스\n핸즈온 실습\n\n\n4 주차 - 2023-07-22\n    \n\n데이터 과학 자료구조\n숫자/범주 --&gt; 데이터프레임\n핸즈온 실습\n\n\n데이터 과학 자료구조\n날짜/공간정보/네트워크\n핸즈온 실습\n\n\n데이터 과학 자료구조\n텍스트/이미지/오디오\n핸즈온 실습\n\n\n5 주차 - 2023-07-29\n    \n\n디지털 글쓰기, 대쉬보드, API 개발\n디지털 보고서(PDF, HTML, PPT)\n핸즈온 실습\n\n\n디지털 글쓰기, 대쉬보드, API 개발\nServerless 대쉬보드, R/Python 대쉬보드\n핸즈온 실습\n\n\n디지털 글쓰기, 대쉬보드, API 개발\n기계학습 모형 API 배포\n핸즈온 실습\n\n\n- 주차 - 2023-08-05\n    \n\n휴가\n휴가\n-\n\n\n6 주차 - 2023-08-12\n    \n\n챗GPT와 오픈소스\n(오픈소스) 거대언어모형(LLM)\n핸즈온 실습\n\n\n챗GPT와 오픈소스\nWrite/Draw/Coding/Reasoning\n핸즈온 실습\n\n\n챗GPT와 오픈소스\nAI 시대 데이터 사이언스 제품개발 방법\n핸즈온 실습\n\n\n7 주차 - 2023-08-19\n    \n\nPrompt Engineering\n사용자 및 개발자를 위한 프롬프트 공학\n핸즈온 실습\n\n\nPrompt Engineering\nOpenAI API 기반 NLP 개발\n핸즈온 실습\n\n\nPrompt Engineering\nOPL(OpenAI, Pinecone, Langchain) 프레임워크\n핸즈온 실습\n\n\n8 주차 - 2023-08-26\n    \n\n챗GPT AI 앱 프로젝트\n오픈소스 LLM 기반 AI 데이터 분석 제품\n핸즈온 실습\n\n\n챗GPT AI 앱 프로젝트\n데이터 사이언스 AutoGPT\n핸즈온 실습\n\n\n챗GPT AI 앱 프로젝트\n챗GPT AI 프로젝트 발표\n핸즈온 실습"
  },
  {
    "objectID": "index.html#국내외-수료증-예시",
    "href": "index.html#국내외-수료증-예시",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2 국내외 수료증 (예시)",
    "text": "2 국내외 수료증 (예시)\n\n\n\n\n국내 건국대 전문과정 수료증\n\n\n\n해외 소프트웨어 카펜트리 수료증"
  },
  {
    "objectID": "index.html#참고-자료",
    "href": "index.html#참고-자료",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3 참고 자료",
    "text": "3 참고 자료\n\n데이터 사이언스\n\nGS 칼텍스 디지털 아카데미: https://r2bit.com/curriculum/\n\n연세대학교 데이터 과학: https://statkclee.github.io/yonsei/ https://statkclee.github.io/yonsei2/\n\n\n\n챗GPT\n\n챗GPT PPT: https://r2bit.com/bitSlide/\n\n챗GPT 디지털 글쓰기: https://r2bit.com/quarto/\n\n챗GPT 디지털 출판: https://r2bit.com/bitPublish/\n\n챗GPT 실습: https://r2bit.com/gpt-edu/\n\n챗GPT 자료: https://r2bit.com/chatGPT/\n\n\n\n커뮤니티\n\n공익법인 한국 R 사용자회: https://r2bit.com/\n\n서울 R 미트업: https://r2bit.com/seoul-r/\n\n한국 R 컨퍼런스: https://use-r.kr/"
  },
  {
    "objectID": "chatGPT_chatGPT.html",
    "href": "chatGPT_chatGPT.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "“챗GPT와 유닉스 쉘(Unix Shell)”은 전세계적으로 수천번의 워크샵과 국내에서도 수년동안 소프트웨어 카펜트리 워크샵 경험을 정식 교재를 통해서 한글화하여 출판을 준비하면서 최근에 큰 반향을 일으키고 있는 챗GPT 관련 내용도 담아내어 한번 학습하여 평생토록 활용할 수 있는 것에 방점을 두고 있다.\n\nOpenAI GPT 제품은 파이썬이 주 개발언어로 되어 있어 파이썬을 기준으로 챗GPT 개발을 진행한다. 일반적인 API를 활용한 파이썬 개발작업흐름은 먼저, 가상환경을 구축하고, API KEY를 발급받고 해당 openai 패키지를 설치하고 헬로월드를 찍고 본격적인 AI 제품 개발을 진행하는 방식으로 추진한다.\n\n\n\n\ngraph LR\n  A[\"1. 가상환경 구축\"] --&gt; B[\"2. API KEY 발급받기\"]\n  B --&gt; C[\"3. API KEY 저장\"]\n  C --&gt; D[\"4. openai 패키지 설치\"]\n  D --&gt; E[\"5. 헬로 월드\"]\n\n\n\n\n\n\n다양한 가상환경이 있어 필요한 패키지를 사용하여 파이썬 가상환경을 구축한다. 파이썬 3.3 버전부터 내장된 venv, 많이 사용되는 virtualenvwrapper, virtualenv 등이 유명하다. 본인 취향에 맞는 가상환경을 특정하여 업무에 사용한다. 다음은 venv를 사용해서 가상 개발환경을 구축하는 것을 예시로 보여주고 있다.\n## 디렉토리 생성 및 프로젝트 디렉토리 이동\nmkdir myproject\ncd myproject\n\n## 가상환경 생성\npython -m venv myenv\n\n## 가상환경 활성화\nmyenv\\Scripts\\activate # 윈도우즈\nsource myenv/bin/activate # 리눅스/맥\n\n## 가상환경 비활성화\ndeactivate\n\n가상환경을 구축한 다음 OpenAI에서 제공하는 공식 API에 접근할 수 있는 API 키를 생성하는 것이다. https://openai.com/api/ 1 로 이동하여 계정을 만듭니다.\n안내에 따라 계정을 생성한 다음 https://platform.openai.com/account/api-keys 2 로 이동하여 API 키를 생성한다.\nAPI 키는 조직에 속해야 하며, 조직을 생성하라는 메시지가 표시되는 경우 조직명을 입력한다. 하나의 조직에 속한 경우 조직 ID(Organization ID)를 별도 생성할 필요는 없다. OpenAI 계정을 통해서는 생성한 API KEY는 다시 볼 수 없기 때문에 생성한 비밀 키를 안전하고 접근하기 쉬운 곳에 저장한다.\n\nAPI KEY를 환경변수로 지정하여 호출하는 방식도 있고, 작업 프로젝트 디렉토리에 로컬 파일에 저장하여 사용하는 방식도 있다. 먼저 윈도우에서 시스템으로 들어가서 환경 변수로 지정하면 해당 변수(OPENAI_API_KEY)를 다양한 프로그램에서 호출하여 사용할 수 있다.\n\n\n\n\n다른 방식은 .env와 같은 파일을 프로젝트 디렉토리 아래 숨긴 파일에 지정하여 사용하는 방식이다. 이런 경우 .gitignore 파일에 버전제어 대상에서 제외시켜 두는 것을 필히 기억한다.\n\n\n\n\n\nOpenAI API KEY도 준비가 되었으면 헬로월드 프로그램을 작성해보자. 개발자가 하나의 조직에 속한 경우, API KEY를 운영체제 환경변수로 지정한 경우 다음과 같이 시스템 환경에서 OPENAI_API_KEY 키를 가져와서 OpenAI에서 제공하는 모델목록을 확인할 수 있다.\n\n#&gt; {\n#&gt;   \"created\": 1677532384,\n#&gt;   \"id\": \"whisper-1\",\n#&gt;   \"object\": \"model\",\n#&gt;   \"owned_by\": \"openai-internal\",\n#&gt;   \"parent\": null,\n#&gt;   \"permission\": [\n#&gt;     {\n#&gt;       \"allow_create_engine\": false,\n#&gt;       \"allow_fine_tuning\": false,\n#&gt;       \"allow_logprobs\": true,\n#&gt;       \"allow_sampling\": true,\n#&gt;       \"allow_search_indices\": false,\n#&gt;       \"allow_view\": true,\n#&gt;       \"created\": 1683912666,\n#&gt;       \"group\": null,\n#&gt;       \"id\": \"modelperm-KlsZlfft3Gma8pI6A8rTnyjs\",\n#&gt;       \"is_blocking\": false,\n#&gt;       \"object\": \"model_permission\",\n#&gt;       \"organization\": \"*\"\n#&gt;     }\n#&gt;   ],\n#&gt;   \"root\": \"whisper-1\"\n#&gt; }\n\n다른 방식은 로컬 파일에 API KEY와 ORG ID 를 저장하고 이를 불러와서 개발에 사용하는 방식이다.\n\n#&gt; {\n#&gt;   \"created\": 1677532384,\n#&gt;   \"id\": \"whisper-1\",\n#&gt;   \"object\": \"model\",\n#&gt;   \"owned_by\": \"openai-internal\",\n#&gt;   \"parent\": null,\n#&gt;   \"permission\": [\n#&gt;     {\n#&gt;       \"allow_create_engine\": false,\n#&gt;       \"allow_fine_tuning\": false,\n#&gt;       \"allow_logprobs\": true,\n#&gt;       \"allow_sampling\": true,\n#&gt;       \"allow_search_indices\": false,\n#&gt;       \"allow_view\": true,\n#&gt;       \"created\": 1683912666,\n#&gt;       \"group\": null,\n#&gt;       \"id\": \"modelperm-KlsZlfft3Gma8pI6A8rTnyjs\",\n#&gt;       \"is_blocking\": false,\n#&gt;       \"object\": \"model_permission\",\n#&gt;       \"organization\": \"*\"\n#&gt;     }\n#&gt;   ],\n#&gt;   \"root\": \"whisper-1\"\n#&gt; }\n\n\nOpenAI에서 제공하는 다양한 모델을 확인할 수 있다. system이 소유한 GPT 모형을 살펴보자.\n\n\n\n\n\n\n\ncreated\n      id\n      object\n      owned_by\n    \n\n\n\n\n\n프로그램 코드(code) 관련된 GPT 모형도 확인할 수 있다.\n\n\n\n\n\n\n\ncreated\n      id\n      object\n      owned_by\n    \n\n\n2022-04-29\nbabbage-code-search-code\nmodel\nopenai-dev\n\n\n2022-04-29\nbabbage-code-search-text\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-babbage-text-001\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-babbage-code-001\nmodel\nopenai-dev\n\n\n2022-04-29\nada-code-search-code\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-ada-text-001\nmodel\nopenai-dev\n\n\n2022-04-29\nada-code-search-text\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-ada-code-001\nmodel\nopenai-dev\n\n\n2022-04-14\ncode-davinci-edit-001\nmodel\nopenai\n\n\n\n\n\n\n\n윈도우 운영체제에서 유닉스 쉘(Shell)을 사용하는 방법은 여러가지가 있다. 윈도우 운영체제에 내장된 명령 프롬프트(cmd.exe)는 OS/2, 윈도우 임베디드, 윈도우 NT 5.0 이상 기반 시스템의 명령어 인터프리터로 친숙하고 최근에 파워쉘(PowerShell)은 마이크로소프트가 개발한, 확장 가능한 명령 줄 인터페이스 셸 및 스크립트 언어를 특징으로 하는 명령어 인터프리터다. 하지만, 이런 cmd, PowerShell은 윈도우 운영체제에서만 동작된다는 한계가 있다. 맥과 리눅스 특히, 클라우드를 지배하고 있는 유닉스 쉘을 윈도우에서도 무리없이 사용하게 된다면 모든 운영체제에서 공통작업을 수행하는데 큰 도움이 될 것이다. 이를 위해 WSL(Windows SubSystem for Linux)를 통해 다양한 리눅스 운영체제를 설치하는 경우와 Git Bash를 설치하여 유닉스 쉘을 윈도우에서도 활용이 가능하다.\n\nWSL(Linux용 Windows 서브시스템)을 통해 우분투(Ubuntu), 데비안(Debian)를 포함한 다양한 리눅스 배포판을 설치할 수 있다. 여기서 데비안를 설치하는 경우를 살펴보자. 기본적인 작업흐름은 다른 리눅스 배포판 설치와 동일한데 먼저 WSL을 설치하고 이어서 데비안 리눅스 배포판을 설치한다.\n윈도우즈 PowerShell을 통해 WSL(Linux용 Windows 하위 시스템)을 설치한다.\n$ wsl --install\n상기 명령을 실행하면 시스템이 WSL과 Linux 배포판(기본값은 우분투)을 설치하고 PC를 재시작한다.\n‘가상 머신 플랫폼’ 선택적 구성 요소를 활성화시킨다. 새 Linux 배포판을 설치하기 전에 ‘가상 머신 플랫폼’ 구성 요소가 활성화되어 있는지 확인해야 하고, 관리자 권한으로 PowerShell을 다시 열고 실행한다.\n$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\nPC를 다시 시작하여 WSL 설치 및 WSL 2로 업데이트를 완료하고, WSL 2를 기본 버전으로 설정한다.\n$ wsl --set-default-version 2\nwsl --install 디폴트로 우분투 리눅스 배포판이 설치되지만 -d Debian 인자를 넣게 되면 데비안 리눅스 배포판을 설치할 수 있다.\n$ wsl --install -d Debian\n정상으로 WSL 데비안 배포판이 설치되었는지 확인한다.\n$ cat /etc/os-release\nPRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"\nNAME=\"Debian GNU/Linux\"\nVERSION_ID=\"11\"\nVERSION=\"11 (bullseye)\"\nVERSION_CODENAME=bullseye\nID=debian\nHOME_URL=\"https://www.debian.org/\"\nSUPPORT_URL=\"https://www.debian.org/support\"\nBUG_REPORT_URL=\"https://bugs.debian.org/\"\n\nOpenAI의 ChatGPT(GPT-3.5)는 콘텐츠 생성에 주된 방점이 있지만 다양한 프로그래밍 코드도 작성함은 물론 유닉스 쉘 프로그램도 작성하여 CLI 생산성을 높이는데 사용될 수 있다. ChatGPT 기능을 활용하여 쉘 명령, 코드 스니펫, 주석, 문서 등을 생성할 수 있다. 즉, 데이터 과학자를 비롯한 개발자가 기존에 업무를 수행하던 방식이 전혀 다르게 된다. 즉, 책, 매뉴얼, 비밀노트(Cheat Sheet), 인터넷 북마크, 구글링 같은 검색없이 바로 터미널에서 바로 정확한 답변을 얻어 귀중한 시간과 노력을 절약할 수 있다. 예를 들어 앞서 프로젝트를 할 때 해당 유닉스 쉘 명령어가 기억나지 않는다고 하면 ShellGPT를 사용하여 해당 작업을 신속하게 수행할 수 있다\nShellGPT를 사용하기 위한 설정은 다음과 같다. ShellGPT가 파이썬으로 개발되어 WSL 데비안 혹은 우분투로 설치한 경우 다음 순서대로 설치를 해야한다.\ncURL은 다양한 통신 프로토콜을 이용하여 데이터를 전송하기 위한 라이브러리와 명령 줄 도구를 제공하는 컴퓨터 소프트웨어로 쉘에서 설치하는데 파이썬 설치파일을 전송받는데 필요하다.\n$ sudo apt install curl\n파이썬을 설치하기 위해서 get-py.py 파일이 필요한데 설치에 앞서 python3-distutils 파일을 설치한다.\n$ sudo apt-get install python3-distutils\n파이썬 설치파일을 다운로드하고 파이썬을 설치하고 python3 명령어를 통해 버전을 확인한다.\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\n$ sudo python3 get-pip.py\n$ python3 --version\nPython 3.9.2\nPython 3.x는 Python 2.x가 설치된 시스템에서 python3로 설치되는 경우가 많으며, python 명령은 이전 버전(Python 2.x)에 링크되어 있는 경우가 많고 리눅스 배포판에서 일반적이다. Python 3.x에서 python 명령을 사용하려면 별칭(alias)을 만들어야 한다.\nnano 편집기를 열고 alias python=python3을 추가하고 저장한다.\n$ nano ~/.bashrc\nalias python=python3\n다시 쉘에서 변경사항을 적용시키면 python 명령어를 실행하게 되면 python3 가 대신 실행되는 것을 확인할 수 있다.\n$ source ~/.bashrc\n$ python --version\nPython 3.9.2\nShellGPT를 설치한다.\n$ sudo pip install shell-gpt==0.9.2\nsgpt를 처음 실행하게 되면 OpenAI API Key를 입력해야 한다. OpenAI에서 API Keys를 생성하여 붙여넣기 하면 ~/.config/shell_gpt/.sgptrc 파일에 저장되어 ShellGPT를 사용하게 된다.\n$ sgpt\nPlease enter your OpenAI API key:\ncat 명령어로 OPENAI_API_KEY가 정상등록된 것을 확인하고 헬로월드를 보내보자. sgpt 다음에 자연어로 지시사항을 보내면 gpt-3.5-turbo 엔진을 통해 자연어를 해석하고 이를 결과로 반환해준다.\n$ cat ~/.config/shell_gpt/.sgptrc\nCHAT_CACHE_PATH=/tmp/chat_cache\nCACHE_PATH=/tmp/cache\nCHAT_CACHE_LENGTH=100\nCACHE_LENGTH=100\nREQUEST_TIMEOUT=60\nDEFAULT_MODEL=gpt-3.5-turbo\nOPENAI_API_HOST=https://api.openai.com\nDEFAULT_COLOR=magenta\nROLE_STORAGE_PATH=/home/xxxxxxxx/.config/shell_gpt/roles\nSYSTEM_ROLES=false\nDEFAULT_EXECUTE_SHELL_CMD=false\nOPENAI_API_KEY=sk-wUxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxFf\n$ sgpt \"대한민국의 수도는 어디야?\"\n서울입니다.\nsgpt 다음에 “현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.” 명령어를 보내면 이를 쉘 명령어로 변환한 후 유닉스 쉘 명령어를 제시하여 준다.\n$ sgpt \"현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.\"\n현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여드리겠습니다. 아래 명령어를 입력해주세요.\n\nfind . -name \"*.txt\"\ntidyverse@dl:/mnt/d/tcs/gpt-shell/shell-lesson-data$ find . -name \"*.txt\"\n./exercise-data/numbers.txt\n./exercise-data/writing/haiku.txt\n./exercise-data/writing/LittleWomen.txt\n./north-pacific-gyre/NENE01729A.txt\n./north-pacific-gyre/NENE01729B.txt\n./north-pacific-gyre/NENE01736A.txt\n./north-pacific-gyre/NENE01751A.txt\n./north-pacific-gyre/NENE01751B.txt\n./north-pacific-gyre/NENE01812A.txt\n./north-pacific-gyre/NENE01843A.txt\n./north-pacific-gyre/NENE01843B.txt\n./north-pacific-gyre/NENE01971Z.txt\n./north-pacific-gyre/NENE01978A.txt\n./north-pacific-gyre/NENE01978B.txt\n./north-pacific-gyre/NENE02018B.txt\n./north-pacific-gyre/NENE02040A.txt\n./north-pacific-gyre/NENE02040B.txt\n./north-pacific-gyre/NENE02040Z.txt\n./north-pacific-gyre/NENE02043A.txt\n./north-pacific-gyre/NENE02043B.txt\n한단계 더 들어가 -s 매개변수를 제공하면 실행([E]xecute) 명령어 기술([D]escribe) 혹은 중단([A]bort)을 지정할 수 있다.\n$ sgpt -s \"현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.\"\nfind . -name \"*.txt\"\n[E]xecute, [D]escribe, [A]bort: D\nSearches for all files with the extension \".txt\" in the current directory and its subdirectories.\n[E]xecute, [D]escribe, [A]bort: E\n./exercise-data/numbers.txt\n./exercise-data/writing/haiku.txt\n./exercise-data/writing/LittleWomen.txt\n./north-pacific-gyre/NENE01729A.txt\n./north-pacific-gyre/NENE01729B.txt\n./north-pacific-gyre/NENE01736A.txt\n./north-pacific-gyre/NENE01751A.txt\n./north-pacific-gyre/NENE01751B.txt\n./north-pacific-gyre/NENE01812A.txt\n./north-pacific-gyre/NENE01843A.txt\n./north-pacific-gyre/NENE01843B.txt\n./north-pacific-gyre/NENE01971Z.txt\n./north-pacific-gyre/NENE01978A.txt\n./north-pacific-gyre/NENE01978B.txt\n./north-pacific-gyre/NENE02018B.txt\n./north-pacific-gyre/NENE02040A.txt\n./north-pacific-gyre/NENE02040B.txt\n./north-pacific-gyre/NENE02040Z.txt\n./north-pacific-gyre/NENE02043A.txt\n./north-pacific-gyre/NENE02043B.txt\n사용방법은 Git Bash를 설치한 후 터미널을 열구 sgpt --shell 혹은 sgpt -s 다음에 자연어를 넣게 되면 해당되는 쉘 명령어를 알려준다. 이를 실행하게 되면 유닉스 쉘을 이용하여 해당 자동화 작업에 생산성을 높일 수 있다. 얼마전까지만해도 한국어는 지원하지 않아 한글로 작성한 다음 번역기를 사용하여 영어로 입력해야 하고 결과를 얻게 되면 이를 실행하는 방식이 활용되었지만 지금은 유닉스 쉘 개념을 이해하여 한국어로 말을 풀어주게 되면 구현이 가능하다.\n\n\n$ sgpt --shell 'List the contents of the current directory and display a special character at the end of each filename to indicate its file type.'\nls -F\n[E]xecute, [D]escribe, [A]bort: E\ngoodiff.sh*      NENE01729B.txt*  NENE01751B.txt*  NENE01843B.txt*  NENE01978B.txt*  NENE02040B.txt*  NENE02043B.txt*\ngoostats.sh*     NENE01736A.txt*  NENE01812A.txt*  NENE01971Z.txt*  NENE02018B.txt*  NENE02040Z.txt*\nNENE01729A.txt*  NENE01751A.txt*  NENE01843A.txt*  NENE01978A.txt*  NENE02040A.txt*  NENE02043A.txt*\n\n$ sgpt -s '현재 디렉터리 콘텐츠를 나열하고 각 파일 이름 끝에 파일 유형을 나타내는 특수 문자를 표시합니다.'\nls -F\n[E]xecute, [D]escribe, [A]bort: E\ngoodiff.sh*      NENE01729B.txt*  NENE01751B.txt*  NENE01843B.txt*  NENE01978B.txt*  NENE02040B.txt*  NENE02043B.txt*\ngoostats.sh*     NENE01736A.txt*  NENE01812A.txt*  NENE01971Z.txt*  NENE02018B.txt*  NENE02040Z.txt*\nNENE01729A.txt*  NENE01751A.txt*  NENE01843A.txt*  NENE01978A.txt*  NENE02040A.txt*  NENE02043A.txt*\n\n\n\n실습데이터는 소프트웨어 카펜트리 유닉스 쉘 학습 페이지에서 직접 다운로드 받을 수 있다. WSL 우분투 혹은 데비안 쉘을 실행시켜 cd 명령어로 다음 디렉토리로 이동한다.\n$ cd /mnt/c/users/사용자명/Desktop\ncurl 명령어로 shell-lesson-data.zip를 다운로드 받고 저장 파일명도 -o 옵션을 주고 동일한 shell-lesson-data.zip 파일명으로 바탕화면(Desktop)에 저장한다.\n$  curl https://swcarpentry.github.io/shell-novice/data/shell-lesson-data.zip -o shell-lesson-data.zip\nunzip 명령어로 shell-lesson-data.zip 파일 압축을 바탕화면(Desktop) 디렉토리에 -d . 선택옵션을 주어 작업을 실행한다.\n$ unzip shell-lesson-data.zip -d .\ntree 명령어로 디렉토리 구조만 -d 옵션을 주어 압축을 푼 shell-lesson-data 폴더 아래 구조를 확인한다.\n$ tree -d shell-lesson-data\nshell-lesson-data\n├── exercise-data\n│   ├── alkanes\n│   ├── animal-counts\n│   ├── creatures\n│   └── writing\n└── north-pacific-gyre\n\n6 directories\n\n\n\n\n\n\n-bash: tree: command not found\n\n\n\ntree 명령어를 실행할 수 없는 경우 다음 명령어로 패키지를 설치하여 문제를 해결한다.\n$ sudo apt-get install tree"
  },
  {
    "objectID": "chatGPT_chatGPT.html#챗gpt-연동",
    "href": "chatGPT_chatGPT.html#챗gpt-연동",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "OpenAI GPT 제품은 파이썬이 주 개발언어로 되어 있어 파이썬을 기준으로 챗GPT 개발을 진행한다. 일반적인 API를 활용한 파이썬 개발작업흐름은 먼저, 가상환경을 구축하고, API KEY를 발급받고 해당 openai 패키지를 설치하고 헬로월드를 찍고 본격적인 AI 제품 개발을 진행하는 방식으로 추진한다.\n\n\n\n\ngraph LR\n  A[\"1. 가상환경 구축\"] --&gt; B[\"2. API KEY 발급받기\"]\n  B --&gt; C[\"3. API KEY 저장\"]\n  C --&gt; D[\"4. openai 패키지 설치\"]\n  D --&gt; E[\"5. 헬로 월드\"]\n\n\n\n\n\n\n다양한 가상환경이 있어 필요한 패키지를 사용하여 파이썬 가상환경을 구축한다. 파이썬 3.3 버전부터 내장된 venv, 많이 사용되는 virtualenvwrapper, virtualenv 등이 유명하다. 본인 취향에 맞는 가상환경을 특정하여 업무에 사용한다. 다음은 venv를 사용해서 가상 개발환경을 구축하는 것을 예시로 보여주고 있다.\n## 디렉토리 생성 및 프로젝트 디렉토리 이동\nmkdir myproject\ncd myproject\n\n## 가상환경 생성\npython -m venv myenv\n\n## 가상환경 활성화\nmyenv\\Scripts\\activate # 윈도우즈\nsource myenv/bin/activate # 리눅스/맥\n\n## 가상환경 비활성화\ndeactivate\n\n가상환경을 구축한 다음 OpenAI에서 제공하는 공식 API에 접근할 수 있는 API 키를 생성하는 것이다. https://openai.com/api/ 1 로 이동하여 계정을 만듭니다.\n안내에 따라 계정을 생성한 다음 https://platform.openai.com/account/api-keys 2 로 이동하여 API 키를 생성한다.\nAPI 키는 조직에 속해야 하며, 조직을 생성하라는 메시지가 표시되는 경우 조직명을 입력한다. 하나의 조직에 속한 경우 조직 ID(Organization ID)를 별도 생성할 필요는 없다. OpenAI 계정을 통해서는 생성한 API KEY는 다시 볼 수 없기 때문에 생성한 비밀 키를 안전하고 접근하기 쉬운 곳에 저장한다.\n\nAPI KEY를 환경변수로 지정하여 호출하는 방식도 있고, 작업 프로젝트 디렉토리에 로컬 파일에 저장하여 사용하는 방식도 있다. 먼저 윈도우에서 시스템으로 들어가서 환경 변수로 지정하면 해당 변수(OPENAI_API_KEY)를 다양한 프로그램에서 호출하여 사용할 수 있다.\n\n\n\n\n다른 방식은 .env와 같은 파일을 프로젝트 디렉토리 아래 숨긴 파일에 지정하여 사용하는 방식이다. 이런 경우 .gitignore 파일에 버전제어 대상에서 제외시켜 두는 것을 필히 기억한다.\n\n\n\n\n\nOpenAI API KEY도 준비가 되었으면 헬로월드 프로그램을 작성해보자. 개발자가 하나의 조직에 속한 경우, API KEY를 운영체제 환경변수로 지정한 경우 다음과 같이 시스템 환경에서 OPENAI_API_KEY 키를 가져와서 OpenAI에서 제공하는 모델목록을 확인할 수 있다.\n\n#&gt; {\n#&gt;   \"created\": 1677532384,\n#&gt;   \"id\": \"whisper-1\",\n#&gt;   \"object\": \"model\",\n#&gt;   \"owned_by\": \"openai-internal\",\n#&gt;   \"parent\": null,\n#&gt;   \"permission\": [\n#&gt;     {\n#&gt;       \"allow_create_engine\": false,\n#&gt;       \"allow_fine_tuning\": false,\n#&gt;       \"allow_logprobs\": true,\n#&gt;       \"allow_sampling\": true,\n#&gt;       \"allow_search_indices\": false,\n#&gt;       \"allow_view\": true,\n#&gt;       \"created\": 1683912666,\n#&gt;       \"group\": null,\n#&gt;       \"id\": \"modelperm-KlsZlfft3Gma8pI6A8rTnyjs\",\n#&gt;       \"is_blocking\": false,\n#&gt;       \"object\": \"model_permission\",\n#&gt;       \"organization\": \"*\"\n#&gt;     }\n#&gt;   ],\n#&gt;   \"root\": \"whisper-1\"\n#&gt; }\n\n다른 방식은 로컬 파일에 API KEY와 ORG ID 를 저장하고 이를 불러와서 개발에 사용하는 방식이다.\n\n#&gt; {\n#&gt;   \"created\": 1677532384,\n#&gt;   \"id\": \"whisper-1\",\n#&gt;   \"object\": \"model\",\n#&gt;   \"owned_by\": \"openai-internal\",\n#&gt;   \"parent\": null,\n#&gt;   \"permission\": [\n#&gt;     {\n#&gt;       \"allow_create_engine\": false,\n#&gt;       \"allow_fine_tuning\": false,\n#&gt;       \"allow_logprobs\": true,\n#&gt;       \"allow_sampling\": true,\n#&gt;       \"allow_search_indices\": false,\n#&gt;       \"allow_view\": true,\n#&gt;       \"created\": 1683912666,\n#&gt;       \"group\": null,\n#&gt;       \"id\": \"modelperm-KlsZlfft3Gma8pI6A8rTnyjs\",\n#&gt;       \"is_blocking\": false,\n#&gt;       \"object\": \"model_permission\",\n#&gt;       \"organization\": \"*\"\n#&gt;     }\n#&gt;   ],\n#&gt;   \"root\": \"whisper-1\"\n#&gt; }\n\n\nOpenAI에서 제공하는 다양한 모델을 확인할 수 있다. system이 소유한 GPT 모형을 살펴보자.\n\n\n\n\n\n\n\ncreated\n      id\n      object\n      owned_by\n    \n\n\n\n\n\n프로그램 코드(code) 관련된 GPT 모형도 확인할 수 있다.\n\n\n\n\n\n\n\ncreated\n      id\n      object\n      owned_by\n    \n\n\n2022-04-29\nbabbage-code-search-code\nmodel\nopenai-dev\n\n\n2022-04-29\nbabbage-code-search-text\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-babbage-text-001\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-babbage-code-001\nmodel\nopenai-dev\n\n\n2022-04-29\nada-code-search-code\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-ada-text-001\nmodel\nopenai-dev\n\n\n2022-04-29\nada-code-search-text\nmodel\nopenai-dev\n\n\n2022-04-29\ncode-search-ada-code-001\nmodel\nopenai-dev\n\n\n2022-04-14\ncode-davinci-edit-001\nmodel\nopenai"
  },
  {
    "objectID": "chatGPT_chatGPT.html#윈도우-쉘-환경",
    "href": "chatGPT_chatGPT.html#윈도우-쉘-환경",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "윈도우 운영체제에서 유닉스 쉘(Shell)을 사용하는 방법은 여러가지가 있다. 윈도우 운영체제에 내장된 명령 프롬프트(cmd.exe)는 OS/2, 윈도우 임베디드, 윈도우 NT 5.0 이상 기반 시스템의 명령어 인터프리터로 친숙하고 최근에 파워쉘(PowerShell)은 마이크로소프트가 개발한, 확장 가능한 명령 줄 인터페이스 셸 및 스크립트 언어를 특징으로 하는 명령어 인터프리터다. 하지만, 이런 cmd, PowerShell은 윈도우 운영체제에서만 동작된다는 한계가 있다. 맥과 리눅스 특히, 클라우드를 지배하고 있는 유닉스 쉘을 윈도우에서도 무리없이 사용하게 된다면 모든 운영체제에서 공통작업을 수행하는데 큰 도움이 될 것이다. 이를 위해 WSL(Windows SubSystem for Linux)를 통해 다양한 리눅스 운영체제를 설치하는 경우와 Git Bash를 설치하여 유닉스 쉘을 윈도우에서도 활용이 가능하다.\n\nWSL(Linux용 Windows 서브시스템)을 통해 우분투(Ubuntu), 데비안(Debian)를 포함한 다양한 리눅스 배포판을 설치할 수 있다. 여기서 데비안를 설치하는 경우를 살펴보자. 기본적인 작업흐름은 다른 리눅스 배포판 설치와 동일한데 먼저 WSL을 설치하고 이어서 데비안 리눅스 배포판을 설치한다.\n윈도우즈 PowerShell을 통해 WSL(Linux용 Windows 하위 시스템)을 설치한다.\n$ wsl --install\n상기 명령을 실행하면 시스템이 WSL과 Linux 배포판(기본값은 우분투)을 설치하고 PC를 재시작한다.\n‘가상 머신 플랫폼’ 선택적 구성 요소를 활성화시킨다. 새 Linux 배포판을 설치하기 전에 ‘가상 머신 플랫폼’ 구성 요소가 활성화되어 있는지 확인해야 하고, 관리자 권한으로 PowerShell을 다시 열고 실행한다.\n$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\nPC를 다시 시작하여 WSL 설치 및 WSL 2로 업데이트를 완료하고, WSL 2를 기본 버전으로 설정한다.\n$ wsl --set-default-version 2\nwsl --install 디폴트로 우분투 리눅스 배포판이 설치되지만 -d Debian 인자를 넣게 되면 데비안 리눅스 배포판을 설치할 수 있다.\n$ wsl --install -d Debian\n정상으로 WSL 데비안 배포판이 설치되었는지 확인한다.\n$ cat /etc/os-release\nPRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"\nNAME=\"Debian GNU/Linux\"\nVERSION_ID=\"11\"\nVERSION=\"11 (bullseye)\"\nVERSION_CODENAME=bullseye\nID=debian\nHOME_URL=\"https://www.debian.org/\"\nSUPPORT_URL=\"https://www.debian.org/support\"\nBUG_REPORT_URL=\"https://bugs.debian.org/\"\n\nOpenAI의 ChatGPT(GPT-3.5)는 콘텐츠 생성에 주된 방점이 있지만 다양한 프로그래밍 코드도 작성함은 물론 유닉스 쉘 프로그램도 작성하여 CLI 생산성을 높이는데 사용될 수 있다. ChatGPT 기능을 활용하여 쉘 명령, 코드 스니펫, 주석, 문서 등을 생성할 수 있다. 즉, 데이터 과학자를 비롯한 개발자가 기존에 업무를 수행하던 방식이 전혀 다르게 된다. 즉, 책, 매뉴얼, 비밀노트(Cheat Sheet), 인터넷 북마크, 구글링 같은 검색없이 바로 터미널에서 바로 정확한 답변을 얻어 귀중한 시간과 노력을 절약할 수 있다. 예를 들어 앞서 프로젝트를 할 때 해당 유닉스 쉘 명령어가 기억나지 않는다고 하면 ShellGPT를 사용하여 해당 작업을 신속하게 수행할 수 있다\nShellGPT를 사용하기 위한 설정은 다음과 같다. ShellGPT가 파이썬으로 개발되어 WSL 데비안 혹은 우분투로 설치한 경우 다음 순서대로 설치를 해야한다.\ncURL은 다양한 통신 프로토콜을 이용하여 데이터를 전송하기 위한 라이브러리와 명령 줄 도구를 제공하는 컴퓨터 소프트웨어로 쉘에서 설치하는데 파이썬 설치파일을 전송받는데 필요하다.\n$ sudo apt install curl\n파이썬을 설치하기 위해서 get-py.py 파일이 필요한데 설치에 앞서 python3-distutils 파일을 설치한다.\n$ sudo apt-get install python3-distutils\n파이썬 설치파일을 다운로드하고 파이썬을 설치하고 python3 명령어를 통해 버전을 확인한다.\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\n$ sudo python3 get-pip.py\n$ python3 --version\nPython 3.9.2\nPython 3.x는 Python 2.x가 설치된 시스템에서 python3로 설치되는 경우가 많으며, python 명령은 이전 버전(Python 2.x)에 링크되어 있는 경우가 많고 리눅스 배포판에서 일반적이다. Python 3.x에서 python 명령을 사용하려면 별칭(alias)을 만들어야 한다.\nnano 편집기를 열고 alias python=python3을 추가하고 저장한다.\n$ nano ~/.bashrc\nalias python=python3\n다시 쉘에서 변경사항을 적용시키면 python 명령어를 실행하게 되면 python3 가 대신 실행되는 것을 확인할 수 있다.\n$ source ~/.bashrc\n$ python --version\nPython 3.9.2\nShellGPT를 설치한다.\n$ sudo pip install shell-gpt==0.9.2\nsgpt를 처음 실행하게 되면 OpenAI API Key를 입력해야 한다. OpenAI에서 API Keys를 생성하여 붙여넣기 하면 ~/.config/shell_gpt/.sgptrc 파일에 저장되어 ShellGPT를 사용하게 된다.\n$ sgpt\nPlease enter your OpenAI API key:\ncat 명령어로 OPENAI_API_KEY가 정상등록된 것을 확인하고 헬로월드를 보내보자. sgpt 다음에 자연어로 지시사항을 보내면 gpt-3.5-turbo 엔진을 통해 자연어를 해석하고 이를 결과로 반환해준다.\n$ cat ~/.config/shell_gpt/.sgptrc\nCHAT_CACHE_PATH=/tmp/chat_cache\nCACHE_PATH=/tmp/cache\nCHAT_CACHE_LENGTH=100\nCACHE_LENGTH=100\nREQUEST_TIMEOUT=60\nDEFAULT_MODEL=gpt-3.5-turbo\nOPENAI_API_HOST=https://api.openai.com\nDEFAULT_COLOR=magenta\nROLE_STORAGE_PATH=/home/xxxxxxxx/.config/shell_gpt/roles\nSYSTEM_ROLES=false\nDEFAULT_EXECUTE_SHELL_CMD=false\nOPENAI_API_KEY=sk-wUxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxFf\n$ sgpt \"대한민국의 수도는 어디야?\"\n서울입니다.\nsgpt 다음에 “현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.” 명령어를 보내면 이를 쉘 명령어로 변환한 후 유닉스 쉘 명령어를 제시하여 준다.\n$ sgpt \"현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.\"\n현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여드리겠습니다. 아래 명령어를 입력해주세요.\n\nfind . -name \"*.txt\"\ntidyverse@dl:/mnt/d/tcs/gpt-shell/shell-lesson-data$ find . -name \"*.txt\"\n./exercise-data/numbers.txt\n./exercise-data/writing/haiku.txt\n./exercise-data/writing/LittleWomen.txt\n./north-pacific-gyre/NENE01729A.txt\n./north-pacific-gyre/NENE01729B.txt\n./north-pacific-gyre/NENE01736A.txt\n./north-pacific-gyre/NENE01751A.txt\n./north-pacific-gyre/NENE01751B.txt\n./north-pacific-gyre/NENE01812A.txt\n./north-pacific-gyre/NENE01843A.txt\n./north-pacific-gyre/NENE01843B.txt\n./north-pacific-gyre/NENE01971Z.txt\n./north-pacific-gyre/NENE01978A.txt\n./north-pacific-gyre/NENE01978B.txt\n./north-pacific-gyre/NENE02018B.txt\n./north-pacific-gyre/NENE02040A.txt\n./north-pacific-gyre/NENE02040B.txt\n./north-pacific-gyre/NENE02040Z.txt\n./north-pacific-gyre/NENE02043A.txt\n./north-pacific-gyre/NENE02043B.txt\n한단계 더 들어가 -s 매개변수를 제공하면 실행([E]xecute) 명령어 기술([D]escribe) 혹은 중단([A]bort)을 지정할 수 있다.\n$ sgpt -s \"현재 폴더 및 하위 폴더에 있는 모든 txt 파일을 보여주세요.\"\nfind . -name \"*.txt\"\n[E]xecute, [D]escribe, [A]bort: D\nSearches for all files with the extension \".txt\" in the current directory and its subdirectories.\n[E]xecute, [D]escribe, [A]bort: E\n./exercise-data/numbers.txt\n./exercise-data/writing/haiku.txt\n./exercise-data/writing/LittleWomen.txt\n./north-pacific-gyre/NENE01729A.txt\n./north-pacific-gyre/NENE01729B.txt\n./north-pacific-gyre/NENE01736A.txt\n./north-pacific-gyre/NENE01751A.txt\n./north-pacific-gyre/NENE01751B.txt\n./north-pacific-gyre/NENE01812A.txt\n./north-pacific-gyre/NENE01843A.txt\n./north-pacific-gyre/NENE01843B.txt\n./north-pacific-gyre/NENE01971Z.txt\n./north-pacific-gyre/NENE01978A.txt\n./north-pacific-gyre/NENE01978B.txt\n./north-pacific-gyre/NENE02018B.txt\n./north-pacific-gyre/NENE02040A.txt\n./north-pacific-gyre/NENE02040B.txt\n./north-pacific-gyre/NENE02040Z.txt\n./north-pacific-gyre/NENE02043A.txt\n./north-pacific-gyre/NENE02043B.txt\n사용방법은 Git Bash를 설치한 후 터미널을 열구 sgpt --shell 혹은 sgpt -s 다음에 자연어를 넣게 되면 해당되는 쉘 명령어를 알려준다. 이를 실행하게 되면 유닉스 쉘을 이용하여 해당 자동화 작업에 생산성을 높일 수 있다. 얼마전까지만해도 한국어는 지원하지 않아 한글로 작성한 다음 번역기를 사용하여 영어로 입력해야 하고 결과를 얻게 되면 이를 실행하는 방식이 활용되었지만 지금은 유닉스 쉘 개념을 이해하여 한국어로 말을 풀어주게 되면 구현이 가능하다.\n\n\n$ sgpt --shell 'List the contents of the current directory and display a special character at the end of each filename to indicate its file type.'\nls -F\n[E]xecute, [D]escribe, [A]bort: E\ngoodiff.sh*      NENE01729B.txt*  NENE01751B.txt*  NENE01843B.txt*  NENE01978B.txt*  NENE02040B.txt*  NENE02043B.txt*\ngoostats.sh*     NENE01736A.txt*  NENE01812A.txt*  NENE01971Z.txt*  NENE02018B.txt*  NENE02040Z.txt*\nNENE01729A.txt*  NENE01751A.txt*  NENE01843A.txt*  NENE01978A.txt*  NENE02040A.txt*  NENE02043A.txt*\n\n$ sgpt -s '현재 디렉터리 콘텐츠를 나열하고 각 파일 이름 끝에 파일 유형을 나타내는 특수 문자를 표시합니다.'\nls -F\n[E]xecute, [D]escribe, [A]bort: E\ngoodiff.sh*      NENE01729B.txt*  NENE01751B.txt*  NENE01843B.txt*  NENE01978B.txt*  NENE02040B.txt*  NENE02043B.txt*\ngoostats.sh*     NENE01736A.txt*  NENE01812A.txt*  NENE01971Z.txt*  NENE02018B.txt*  NENE02040Z.txt*\nNENE01729A.txt*  NENE01751A.txt*  NENE01843A.txt*  NENE01978A.txt*  NENE02040A.txt*  NENE02043A.txt*"
  },
  {
    "objectID": "chatGPT_chatGPT.html#실습-데이터-준비",
    "href": "chatGPT_chatGPT.html#실습-데이터-준비",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "실습데이터는 소프트웨어 카펜트리 유닉스 쉘 학습 페이지에서 직접 다운로드 받을 수 있다. WSL 우분투 혹은 데비안 쉘을 실행시켜 cd 명령어로 다음 디렉토리로 이동한다.\n$ cd /mnt/c/users/사용자명/Desktop\ncurl 명령어로 shell-lesson-data.zip를 다운로드 받고 저장 파일명도 -o 옵션을 주고 동일한 shell-lesson-data.zip 파일명으로 바탕화면(Desktop)에 저장한다.\n$  curl https://swcarpentry.github.io/shell-novice/data/shell-lesson-data.zip -o shell-lesson-data.zip\nunzip 명령어로 shell-lesson-data.zip 파일 압축을 바탕화면(Desktop) 디렉토리에 -d . 선택옵션을 주어 작업을 실행한다.\n$ unzip shell-lesson-data.zip -d .\ntree 명령어로 디렉토리 구조만 -d 옵션을 주어 압축을 푼 shell-lesson-data 폴더 아래 구조를 확인한다.\n$ tree -d shell-lesson-data\nshell-lesson-data\n├── exercise-data\n│   ├── alkanes\n│   ├── animal-counts\n│   ├── creatures\n│   └── writing\n└── north-pacific-gyre\n\n6 directories\n\n\n\n\n\n\n-bash: tree: command not found\n\n\n\ntree 명령어를 실행할 수 없는 경우 다음 명령어로 패키지를 설치하여 문제를 해결한다.\n$ sudo apt-get install tree"
  },
  {
    "objectID": "chatGPT_chatGPT.html#footnotes",
    "href": "chatGPT_chatGPT.html#footnotes",
    "title": "챗GPT 데이터 사이언스",
    "section": "각주",
    "text": "각주\n\nhttps://openai.com/api/↩︎\nhttps://platform.openai.com/account/api-keys↩︎"
  },
  {
    "objectID": "markdown.html",
    "href": "markdown.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "JSON(Javascript Object Notation, 자바스크립트 객체 표기법)은 가장 흔한 일반적인 웹 데이터 형식으로 데이터를 저장하거나 전송할 때 많이 사용되는 가벼운 자료형으로, 사람이 읽고 쓰기 쉬우며, 기계가 파싱하고 생성하기도 쉽다.\n\n언어 독립성: JSON은 JavaScript에서 파생되었지만, 거의 모든 프로그래밍 언어는 JSON 데이터를 파싱하는 라이브러리를 가지고 있고, 다양한 언어로 작성된 시스템 간에 데이터를 교환하는 데 아주 유용하게 작용한다.\n데이터 구조: JSON은 데이터를 구조화하는 방법도 제공하여 Nested JSON을 통해 중첩된 키-값 쌍을 통해 복잡한 데이터 구조를 표현할 수 있다.\n웹 표준: JSON은 웹 애플리케이션에서 서버와 클라이언트 사이의 데이터를 교환하는 표준으로 AJAX(Asynchronous JavaScript And XML)와 같은 기술이 이 형식을 기반으로 동작한다.\n읽기 쉬움: JSON 형식은 사람이 읽기 쉽기 때문에 디버깅을 도울 뿐만 아니라, 데이터를 보다 쉽게 이해하고 수정할 수 있다는 장점이 있다.\n\n\n\n\n\n\n\n\n\nName\n      Age\n    \n\n\nAlice\n25\n\n\nBob\n30\n\n\nCharlie\n35\n\n\n\n\n\n\n6가지 JSON 파일 표현방법\n\nrecord: 각 레코드가 사전인 목록.\ncolumn: 키가 열 레이블인 중첩 딕셔너리.\nsplit: 인덱스, 열, 데이터가 포함된 딕셔너리.\nindex: 키가 인덱스 레이블인 중첩 딕셔너리.\nvalues: 그냥 값 배열.\ntable: 스키마와 데이터를 포함하는 중첩된 딕셔너리(Apache Arrow 형식과 상호 운용성을 목표로 하는 더 복잡한 형식).\n\n\n\nrecord\ncolumn\nsplit\nindex\nvalues\ntable\n\n\n\n[\n    {\"Name\": \"Alice\", \"Age\": 25},\n    {\"Name\": \"Bob\", \"Age\": 30},\n    {\"Name\": \"Charlie\", \"Age\": 35}\n]\n\n\n{\n    \"Name\": {\"0\": \"Alice\", \"1\": \"Bob\", \"2\": \"Charlie\"},\n    \"Age\": {\"0\": 25, \"1\": 30, \"2\": 35}\n}\n\n\n{\n    \"columns\": [\"Name\", \"Age\"],\n    \"index\": [0, 1, 2],\n    \"data\": [[\"Alice\", 25], [\"Bob\", 30], [\"Charlie\", 35]]\n}\n\n\n{\n    \"0\": {\"Name\": \"Alice\", \"Age\": 25},\n    \"1\": {\"Name\": \"Bob\", \"Age\": 30},\n    \"2\": {\"Name\": \"Charlie\", \"Age\": 35}\n}\n\n\n[\n    [\"Alice\", 25],\n    [\"Bob\", 30],\n    [\"Charlie\", 35]\n]\n\n\n{\n    \"schema\": {\n        \"fields\": [\n            {\"name\": \"index\", \"type\": \"integer\"},\n            {\"name\": \"Name\", \"type\": \"string\"},\n            {\"name\": \"Age\", \"type\": \"integer\"}\n        ],\n        \"primaryKey\": [\"index\"],\n        \"pandas_version\": \"0.20.0\"\n    },\n    \"data\": [\n        {\"index\": 0, \"Name\": \"Alice\", \"Age\": 25},\n        {\"index\": 1, \"Name\": \"Bob\", \"Age\": 30},\n        {\"index\": 2, \"Name\": \"Charlie\", \"Age\": 35}\n    ]\n}"
  },
  {
    "objectID": "markdown.html#문서",
    "href": "markdown.html#문서",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.1 문서",
    "text": "3.1 문서\nAI Hub - 공공행정문서 OCR 웹사이트에서 공공행정문서 데이터를 바탕으로 OCR 작업을 수행한다.\n\n\n스캔 문서\nOCR 된 텍스트\n네이버 OCR\n\n\n\n\n\n\n\nAI Hub - 공공행정문서 OCR\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n네이버 CLOVA OCR\n\n\n\n\n3.1.1 실습 문서\n\n\n\n\n텍스트\n\n\n\n표"
  },
  {
    "objectID": "markdown.html#수식",
    "href": "markdown.html#수식",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.2 수식",
    "text": "3.2 수식\n챗GPT가 선정한 수학에서 가장 유명한 3대 수식\n\n\n\n오일러 항등식(Euler’s Identity): \\(e^{i\\pi} + 1 = 0\\)\n\n피타고라스 정리(The Pythagorean Theorem): \\(a^2 + b^2 = c^2\\)\n\n가우스 적분(The Gaussian Integral): \\(\\int_{-\\infty}^{\\infty} e^{-x^2} \\, dx = \\sqrt{\\pi}\\)\n\n\n\n\n\n\n\n\n\nMathPix https://snip.mathpix.com/ 웹사이트를 통해 수식을 OCR 할 수 있다.\n\n\n\n\n\n\n\n\n오일러 항등식(Euler’s Identity): \\(e^{i \\pi}+1=0\\)\n\n피타고라스 정리(The Pythagorean Theorem): \\(a^2+b^2=c^2\\)\n\n가우스 적분(The Gaussian Integral): \\(\\int_{-\\infty}^{\\infty} e^{-x^2} d x=\\sqrt{\\pi}\\)\n\n\n\n\n\n3.2.1 R API\n\\[\\int _ { - \\infty } ^ { \\infty } e ^ { - x ^ { 2 } } d x = \\sqrt { \\pi }\\]"
  },
  {
    "objectID": "markdown.html#표-table",
    "href": "markdown.html#표-table",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.3 표 (Table)",
    "text": "3.3 표 (Table)\n\n3.3.1 IAEA PDF\nIAEA Fukushima Daiichi ALPS Treated Water Discharge - Comprehensive Report 최종 보고서에 담긴 표를 추출하자.\n\n\n\n\n\n\n\n\n\n3.3.2 PDF 표\n\n\n\n\n\n\n\n\nCOMPARISON OF TEPCO’S DETECTION LIMITS WITH RESPECTIVE JAPANESE\nREGULATORY LIMITS FOR DISCHARGE\n    \n\natom\n      regulatory_limit\n      detection_limit\n      DL_RL\n    \n\n\n\n3H\n60,000\n210.000\n0.35000\n\n\n14C\n2,000\n1.600\n0.08000\n\n\n54Mn\n1,000\n0.047\n0.00470\n\n\n55Fe\n2,000\n19.000\n0.94000\n\n\n60Co\n200\n0.028\n0.01400\n\n\n63Ni\n6,000\n8.100\n0.13000\n\n\n79Se\n200\n0.850\n0.43000\n\n\n90Sr\n30\n0.069\n0.23000\n\n\n99Tc\n1,000\n0.430\n0.04300\n\n\n106Ru\n100\n0.420\n0.41000\n\n\n125Sb\n800\n0.100\n0.01300\n\n\n129I\n9\n0.026\n0.29000\n\n\n134Cs\n60\n0.057\n0.10000\n\n\n137Cs\n90\n0.036\n0.04000\n\n\n144Ce\n200\n0.590\n0.30000\n\n\n147Pm\n3,000\n0.320\n0.01100\n\n\n151Sm\n8,000\n0.012\n0.00015\n\n\n154Eu\n400\n0.072\n0.01800\n\n\n155Eu\n3,000\n0.190\n0.00630\n\n\n234U\n20\n0.031\n0.15000\n\n\n238U\n20\n0.031\n0.15000\n\n\n237Np\n9\n0.031\n0.34000\n\n\n238Pu\n4\n0.031\n0.76000\n\n\n239Pu\n4\n0.031\n0.76000\n\n\n240Pu\n4\n0.031\n0.76000\n\n\n241Pu\n200\n0.840\n0.42000\n\n\n241Am\n5\n0.031\n0.61000\n\n\n244Cm\n7\n0.031\n0.44000"
  },
  {
    "objectID": "markdown.html#예제",
    "href": "markdown.html#예제",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "Name\n      Age\n    \n\n\nAlice\n25\n\n\nBob\n30\n\n\nCharlie\n35\n\n\n\n\n\n\n6가지 JSON 파일 표현방법\n\nrecord: 각 레코드가 사전인 목록.\ncolumn: 키가 열 레이블인 중첩 딕셔너리.\nsplit: 인덱스, 열, 데이터가 포함된 딕셔너리.\nindex: 키가 인덱스 레이블인 중첩 딕셔너리.\nvalues: 그냥 값 배열.\ntable: 스키마와 데이터를 포함하는 중첩된 딕셔너리(Apache Arrow 형식과 상호 운용성을 목표로 하는 더 복잡한 형식).\n\n\n\nrecord\ncolumn\nsplit\nindex\nvalues\ntable\n\n\n\n[\n    {\"Name\": \"Alice\", \"Age\": 25},\n    {\"Name\": \"Bob\", \"Age\": 30},\n    {\"Name\": \"Charlie\", \"Age\": 35}\n]\n\n\n{\n    \"Name\": {\"0\": \"Alice\", \"1\": \"Bob\", \"2\": \"Charlie\"},\n    \"Age\": {\"0\": 25, \"1\": 30, \"2\": 35}\n}\n\n\n{\n    \"columns\": [\"Name\", \"Age\"],\n    \"index\": [0, 1, 2],\n    \"data\": [[\"Alice\", 25], [\"Bob\", 30], [\"Charlie\", 35]]\n}\n\n\n{\n    \"0\": {\"Name\": \"Alice\", \"Age\": 25},\n    \"1\": {\"Name\": \"Bob\", \"Age\": 30},\n    \"2\": {\"Name\": \"Charlie\", \"Age\": 35}\n}\n\n\n[\n    [\"Alice\", 25],\n    [\"Bob\", 30],\n    [\"Charlie\", 35]\n]\n\n\n{\n    \"schema\": {\n        \"fields\": [\n            {\"name\": \"index\", \"type\": \"integer\"},\n            {\"name\": \"Name\", \"type\": \"string\"},\n            {\"name\": \"Age\", \"type\": \"integer\"}\n        ],\n        \"primaryKey\": [\"index\"],\n        \"pandas_version\": \"0.20.0\"\n    },\n    \"data\": [\n        {\"index\": 0, \"Name\": \"Alice\", \"Age\": 25},\n        {\"index\": 1, \"Name\": \"Bob\", \"Age\": 30},\n        {\"index\": 2, \"Name\": \"Charlie\", \"Age\": 35}\n    ]\n}"
  },
  {
    "objectID": "api_programming.html",
    "href": "api_programming.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "파머 펭귄 데이터셋 웹주소에서 데이터를 마치 로컬파일 데이터셋을 가져오듯이 동일한 방식으로 가져온다.\n\n코드from urllib.request import urlretrieve\nimport pandas as pd\n\nurl = 'https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv'\n\nurlretrieve(url, 'data/penguins.csv')\n\n# Read file into a DataFrame and print its head\n#&gt; ('data/penguins.csv', &lt;http.client.HTTPMessage object at 0x0000021ED534B490&gt;)\npenguins_df = pd.read_csv('data/penguins.csv', sep=',')\nprint(penguins_df.head())\n#&gt;    rowid species     island  ...  body_mass_g     sex  year\n#&gt; 0      1  Adelie  Torgersen  ...       3750.0    male  2007\n#&gt; 1      2  Adelie  Torgersen  ...       3800.0  female  2007\n#&gt; 2      3  Adelie  Torgersen  ...       3250.0  female  2007\n#&gt; 3      4  Adelie  Torgersen  ...          NaN     NaN  2007\n#&gt; 4      5  Adelie  Torgersen  ...       3450.0  female  2007\n#&gt; \n#&gt; [5 rows x 9 columns]\n\n\n\nrequests는 Python에서 HTTP 요청을 보내는 작업을 단순화하고, 사용자 친화적으로 만든 패키지다. GET, POST, DELETE, PUT 등의 다양한 HTTP 메소드를 사용하여 웹 서버와 통신할 수 있고, requests는 JSON 응답을 쉽게 파싱하고, 쿠키를 유지하며, 파일 업로드, HTTP 헤더 조작, SSL 인증 등의 복잡한 작업을 쉽게 처리할 수 있다.\nurllib는 Python의 표준 라이브러리 중 하나지만, 사용법이 다소 복잡하고 번거로운데 반해, requests는 인터페이스가 간결하고 직관적이어서 같은 작업을 더 쉽게 수행할 수 있다.\n\n\nrequests\nurllib\n\n\n\n\n코드import requests\n\nresponse = requests.get('https://r2bit.com')\n\nprint(response.status_code)\nprint(response.text)\n\n\n\n\n\n코드from urllib.request import urlopen\nresponse = urlopen('https://r2bit.com')\n\nprint(response.getcode())\nprint(response.read())\n\n\n\n\n\n\nBeautifulSoup은 Python에서 HTML과 XML 문서를 파싱하기 위한 라이브러리다. 웹 스크래핑 작업에서 특히 유용하며, 복잡하고 잘 정돈되지 않은 웹 페이지에서 데이터를 쉽게 추출할 수 있다.\nBeautifulSoup은 문서를 트리 구조로 파싱하고, 이 트리를 통해 원하는 정보를 찾고, 수정하고, 네비게이트 할 수 있다. 예를 들어, HTML 문서에서 특정 태그를 찾거나, 특정 클래스 또는 ID를 가진 요소를 검색할 수 있다.\nrequests와 BeautifulSoup는 웹 스크래핑 작업에서 함께 사용되는 경우가 많다. 일반적으로 requests를 사용하여 웹페이지의 HTML을 가져오고, 그런 다음 BeautifulSoup을 사용하여 가져온 HTML을 파싱하고 원하는 정보를 추출하는 방식이다.\n\n\n웹사이트 제목\n링크\n\n\n\n\n코드import requests\nfrom bs4 import BeautifulSoup\n\nurl = 'https://r2bit.com'\n\nr = requests.get(url)\n\nhtml_doc = r.text\n\nsoup = BeautifulSoup(html_doc)\n\n# pretty_soup = soup.prettify()\nr2bit_title = soup.title\n\nprint(r2bit_title)\n#&gt; &lt;title&gt;한국 R 사용자회&lt;/title&gt;\n\n\n\n\n\n코드a_tags = soup.find_all('a')\n\nfor link in a_tags:\n    print(link.get('href'))\n#&gt; ./index.html\n#&gt; ./index.html\n#&gt; #\n#&gt; ./about.html\n#&gt; https://r2bit.com/chatGPT/\n#&gt; ./bitstat.html\n#&gt; ./packages.html\n#&gt; ./book.html\n#&gt; ./data.html\n#&gt; #\n#&gt; ./edutech.html\n#&gt; ./swc.html\n#&gt; ./learnr.html\n#&gt; ./training.html\n#&gt; ./blog.html\n#&gt; #\n#&gt; https://use-r.kr/\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://tidyverse-korea.github.io/seoul-R/\n#&gt; https://r2bit.com/seoul-r/\n#&gt; https://quarto.org/\n#&gt; ./contest.html\n#&gt; https://r2bit.com\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://github.com/bit2r/quarto\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; None\n#&gt; None\n#&gt; None\n#&gt; https://r2bit.com/bitSlide/slideshow/202210-hongik-v2\n#&gt; https://statkclee.github.io/ds-authoring/ds-world-student.html\n#&gt; None\n#&gt; None\n#&gt; https://www.sharingkorea.net/gboard/\n#&gt; https://r2bit.com/sen\n#&gt; https://choonghyunryu.github.io/workshop_lecture/\n#&gt; None\n#&gt; None\n#&gt; https://www.msit.go.kr/\n#&gt; #서울-r-미트업\n#&gt; #r-사용자회-회원-가입\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://r-community.org/usergroups/\n#&gt; https://r2bit.com/\n#&gt; https://use-r.kr/\n#&gt; https://r2bit.com/seoul-r\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; https://korea-r-user-group.slack.com\n#&gt; https://forms.gle/ByJy34PkFdMJXHbe6\n#&gt; https://quarto.org/"
  },
  {
    "objectID": "api_programming.html#예제",
    "href": "api_programming.html#예제",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 예제",
    "text": "2.1 예제\n\n코드library(tidyverse)\n\ndataframe_df &lt;- tribble(~\"Name\", ~\"Age\",\n                        \"Alice\", 25,\n                        \"Bob\", 30,\n                        \"Charlie\", 35)\n\ngt::gt(dataframe_df)\n\n\n\n\n\n\nName\n      Age\n    \n\n\nAlice\n25\n\n\nBob\n30\n\n\nCharlie\n35\n\n\n\n\n\n\n6가지 JSON 파일 표현방법\n\nrecord: 각 레코드가 사전인 목록.\ncolumn: 키가 열 레이블인 중첩 딕셔너리.\nsplit: 인덱스, 열, 데이터가 포함된 딕셔너리.\nindex: 키가 인덱스 레이블인 중첩 딕셔너리.\nvalues: 그냥 값 배열.\ntable: 스키마와 데이터를 포함하는 중첩된 딕셔너리(Apache Arrow 형식과 상호 운용성을 목표로 하는 더 복잡한 형식).\n\n\n\nrecord\ncolumn\nsplit\nindex\nvalues\ntable\n\n\n\n[\n    {\"Name\": \"Alice\", \"Age\": 25},\n    {\"Name\": \"Bob\", \"Age\": 30},\n    {\"Name\": \"Charlie\", \"Age\": 35}\n]\n\n\n{\n    \"Name\": {\"0\": \"Alice\", \"1\": \"Bob\", \"2\": \"Charlie\"},\n    \"Age\": {\"0\": 25, \"1\": 30, \"2\": 35}\n}\n\n\n{\n    \"columns\": [\"Name\", \"Age\"],\n    \"index\": [0, 1, 2],\n    \"data\": [[\"Alice\", 25], [\"Bob\", 30], [\"Charlie\", 35]]\n}\n\n\n{\n    \"0\": {\"Name\": \"Alice\", \"Age\": 25},\n    \"1\": {\"Name\": \"Bob\", \"Age\": 30},\n    \"2\": {\"Name\": \"Charlie\", \"Age\": 35}\n}\n\n\n[\n    [\"Alice\", 25],\n    [\"Bob\", 30],\n    [\"Charlie\", 35]\n]\n\n\n{\n    \"schema\": {\n        \"fields\": [\n            {\"name\": \"index\", \"type\": \"integer\"},\n            {\"name\": \"Name\", \"type\": \"string\"},\n            {\"name\": \"Age\", \"type\": \"integer\"}\n        ],\n        \"primaryKey\": [\"index\"],\n        \"pandas_version\": \"0.20.0\"\n    },\n    \"data\": [\n        {\"index\": 0, \"Name\": \"Alice\", \"Age\": 25},\n        {\"index\": 1, \"Name\": \"Bob\", \"Age\": 30},\n        {\"index\": 2, \"Name\": \"Charlie\", \"Age\": 35}\n    ]\n}"
  },
  {
    "objectID": "api_programming.html#urllib",
    "href": "api_programming.html#urllib",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "파머 펭귄 데이터셋 웹주소에서 데이터를 마치 로컬파일 데이터셋을 가져오듯이 동일한 방식으로 가져온다.\n\n코드from urllib.request import urlretrieve\nimport pandas as pd\n\nurl = 'https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv'\n\nurlretrieve(url, 'data/penguins.csv')\n\n# Read file into a DataFrame and print its head\n#&gt; ('data/penguins.csv', &lt;http.client.HTTPMessage object at 0x0000021ED534B490&gt;)\npenguins_df = pd.read_csv('data/penguins.csv', sep=',')\nprint(penguins_df.head())\n#&gt;    rowid species     island  ...  body_mass_g     sex  year\n#&gt; 0      1  Adelie  Torgersen  ...       3750.0    male  2007\n#&gt; 1      2  Adelie  Torgersen  ...       3800.0  female  2007\n#&gt; 2      3  Adelie  Torgersen  ...       3250.0  female  2007\n#&gt; 3      4  Adelie  Torgersen  ...          NaN     NaN  2007\n#&gt; 4      5  Adelie  Torgersen  ...       3450.0  female  2007\n#&gt; \n#&gt; [5 rows x 9 columns]"
  },
  {
    "objectID": "api_programming.html#requests",
    "href": "api_programming.html#requests",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "requests는 Python에서 HTTP 요청을 보내는 작업을 단순화하고, 사용자 친화적으로 만든 패키지다. GET, POST, DELETE, PUT 등의 다양한 HTTP 메소드를 사용하여 웹 서버와 통신할 수 있고, requests는 JSON 응답을 쉽게 파싱하고, 쿠키를 유지하며, 파일 업로드, HTTP 헤더 조작, SSL 인증 등의 복잡한 작업을 쉽게 처리할 수 있다.\nurllib는 Python의 표준 라이브러리 중 하나지만, 사용법이 다소 복잡하고 번거로운데 반해, requests는 인터페이스가 간결하고 직관적이어서 같은 작업을 더 쉽게 수행할 수 있다.\n\n\nrequests\nurllib\n\n\n\n\n코드import requests\n\nresponse = requests.get('https://r2bit.com')\n\nprint(response.status_code)\nprint(response.text)\n\n\n\n\n\n코드from urllib.request import urlopen\nresponse = urlopen('https://r2bit.com')\n\nprint(response.getcode())\nprint(response.read())"
  },
  {
    "objectID": "api_programming.html#beautifulsoup",
    "href": "api_programming.html#beautifulsoup",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "BeautifulSoup은 Python에서 HTML과 XML 문서를 파싱하기 위한 라이브러리다. 웹 스크래핑 작업에서 특히 유용하며, 복잡하고 잘 정돈되지 않은 웹 페이지에서 데이터를 쉽게 추출할 수 있다.\nBeautifulSoup은 문서를 트리 구조로 파싱하고, 이 트리를 통해 원하는 정보를 찾고, 수정하고, 네비게이트 할 수 있다. 예를 들어, HTML 문서에서 특정 태그를 찾거나, 특정 클래스 또는 ID를 가진 요소를 검색할 수 있다.\nrequests와 BeautifulSoup는 웹 스크래핑 작업에서 함께 사용되는 경우가 많다. 일반적으로 requests를 사용하여 웹페이지의 HTML을 가져오고, 그런 다음 BeautifulSoup을 사용하여 가져온 HTML을 파싱하고 원하는 정보를 추출하는 방식이다.\n\n\n웹사이트 제목\n링크\n\n\n\n\n코드import requests\nfrom bs4 import BeautifulSoup\n\nurl = 'https://r2bit.com'\n\nr = requests.get(url)\n\nhtml_doc = r.text\n\nsoup = BeautifulSoup(html_doc)\n\n# pretty_soup = soup.prettify()\nr2bit_title = soup.title\n\nprint(r2bit_title)\n#&gt; &lt;title&gt;한국 R 사용자회&lt;/title&gt;\n\n\n\n\n\n코드a_tags = soup.find_all('a')\n\nfor link in a_tags:\n    print(link.get('href'))\n#&gt; ./index.html\n#&gt; ./index.html\n#&gt; #\n#&gt; ./about.html\n#&gt; https://r2bit.com/chatGPT/\n#&gt; ./bitstat.html\n#&gt; ./packages.html\n#&gt; ./book.html\n#&gt; ./data.html\n#&gt; #\n#&gt; ./edutech.html\n#&gt; ./swc.html\n#&gt; ./learnr.html\n#&gt; ./training.html\n#&gt; ./blog.html\n#&gt; #\n#&gt; https://use-r.kr/\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://tidyverse-korea.github.io/seoul-R/\n#&gt; https://r2bit.com/seoul-r/\n#&gt; https://quarto.org/\n#&gt; ./contest.html\n#&gt; https://r2bit.com\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://github.com/bit2r/quarto\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; None\n#&gt; None\n#&gt; None\n#&gt; https://r2bit.com/bitSlide/slideshow/202210-hongik-v2\n#&gt; https://statkclee.github.io/ds-authoring/ds-world-student.html\n#&gt; None\n#&gt; None\n#&gt; https://www.sharingkorea.net/gboard/\n#&gt; https://r2bit.com/sen\n#&gt; https://choonghyunryu.github.io/workshop_lecture/\n#&gt; None\n#&gt; None\n#&gt; https://www.msit.go.kr/\n#&gt; #서울-r-미트업\n#&gt; #r-사용자회-회원-가입\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://r-community.org/usergroups/\n#&gt; https://r2bit.com/\n#&gt; https://use-r.kr/\n#&gt; https://r2bit.com/seoul-r\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; https://korea-r-user-group.slack.com\n#&gt; https://forms.gle/ByJy34PkFdMJXHbe6\n#&gt; https://quarto.org/"
  },
  {
    "objectID": "api_programming.html#json-불러오기",
    "href": "api_programming.html#json-불러오기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 JSON 불러오기",
    "text": "2.2 JSON 불러오기\n다양한 형식으로 데이터프레임 파일을 저장했다면 다음 단계로 이를 파이썬에서 불러오는 방식은 json 패키지를 사용한다.\n\n코드import json\n\nwith open(\"data/json.json\") as json_file:\n    json_data = json.load(json_file)\n\nfor item in json_data:\n    if isinstance(item, dict):  # Check if the item is a dictionary\n        for k in item.keys():\n            print(k + ': ', item[k])\n    \n#&gt; Name:  Alice\n#&gt; Age:  25\n#&gt; Name:  Bob\n#&gt; Age:  30\n#&gt; Name:  Charlie\n#&gt; Age:  35"
  },
  {
    "objectID": "api_programming.html#pandas-불러오기",
    "href": "api_programming.html#pandas-불러오기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 pandas 불러오기",
    "text": "2.3 pandas 불러오기\n\n코드import pandas as pd\n\njson_pd = pd.read_json(\"data/json.json\")\n\nprint(json_pd.describe())\n#&gt;         Age\n#&gt; count   3.0\n#&gt; mean   30.0\n#&gt; std     5.0\n#&gt; min    25.0\n#&gt; 25%    27.5\n#&gt; 50%    30.0\n#&gt; 75%    32.5\n#&gt; max    35.0"
  },
  {
    "objectID": "api_programming.html#omdb-api",
    "href": "api_programming.html#omdb-api",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.1 OMDB API",
    "text": "3.1 OMDB API\nOMDb API - The Open Movie Database에서 영화 API에 대한 다양한 정보를 얻을 수 있다.\n\n\nAPI 사양서\nAPI 시험\n직접 호출\nR API 호출\n파이썬 API 호출\n보안강화\n.env\n\n\n\nOMDb API - The Open Movie Database\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n코드library(httr)\nlibrary(tidyverse)\n\nsquid_game_req &lt;- glue::glue(\"http://www.omdbapi.com/\",\n           \"?i={Sys.getenv('OMDB_API_ID')}\",\n           \"&apikey={Sys.getenv('OMDB_API_KEY')}\",\n           \"&t=squid+game\")\n\nsquid_resp &lt;- GET(squid_game_req)\n\njsonlite::fromJSON(content(squid_resp, \"text\")) %&gt;% \n  enframe() %&gt;% \n  mutate(value = map_chr(value, 1))\n#&gt; # A tibble: 22 × 2\n#&gt;    name     value                                                               \n#&gt;    &lt;chr&gt;    &lt;chr&gt;                                                               \n#&gt;  1 Title    Squid Game                                                          \n#&gt;  2 Year     2021–                                                               \n#&gt;  3 Rated    TV-MA                                                               \n#&gt;  4 Released 17 Sep 2021                                                         \n#&gt;  5 Runtime  N/A                                                                 \n#&gt;  6 Genre    Action, Drama, Mystery                                              \n#&gt;  7 Director N/A                                                                 \n#&gt;  8 Writer   N/A                                                                 \n#&gt;  9 Actors   Lee Jung-jae, Park Hae-soo, Yasushi Iwaki                           \n#&gt; 10 Plot     Hundreds of cash-strapped players accept a strange invitation to co…\n#&gt; # ℹ 12 more rows\n\n\n\n\nimport requests\n\nurl = 'http://www.omdbapi.com/?i=ttxxxxx&apikey=47xxxx&t=squid+game'\n\nr = requests.get(url)\nprint(r.text)\n\n{\"Title\":\"Squid Game\",\"Year\":\"2021–\",\"Rated\":\"TV-MA\",\"Released\":\"17 Sep 2021\",\"Runtime\":\"N/A\",\"Genre\":\"Action, Drama, Mystery\",\"Director\":\"N/A\",\"Writer\":\"N/A\",\"Actors\":\"Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\",\"Plot\":\"Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\",\"Language\":\"Korean, English, Urdu\",\"Country\":\"South Korea\",\"Awards\":\"Won 6 Primetime Emmys. 46 wins & 80 nominations total\",\"Poster\":\"https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\",\"Ratings\":[{\"Source\":\"Internet Movie Database\",\"Value\":\"8.0/10\"}],\"Metascore\":\"N/A\",\"imdbRating\":\"8.0\",\"imdbVotes\":\"482,476\",\"imdbID\":\"tt10919420\",\"Type\":\"series\",\"totalSeasons\":\"1\",\"Response\":\"True\"}\njson_data = r.json()\n\n# Print each key-value pair in json_data\nfor k in json_data.keys():\n    print(k + ': ', json_data[k])\n    \nTitle:  Squid Game\nYear:  2021–\nRated:  TV-MA\nReleased:  17 Sep 2021\nRuntime:  N/A\nGenre:  Action, Drama, Mystery\nDirector:  N/A\nWriter:  N/A\nActors:  Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\nPlot:  Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\nLanguage:  Korean, English, Urdu\nCountry:  South Korea\nAwards:  Won 6 Primetime Emmys. 46 wins & 80 nominations total\nPoster:  https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\nRatings:  [{'Source': 'Internet Movie Database', 'Value': '8.0/10'}]\nMetascore:  N/A\nimdbRating:  8.0\nimdbVotes:  482,476\nimdbID:  tt10919420\nType:  series\ntotalSeasons:  1\nResponse:  True\n\n\n\n코드import requests\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n#&gt; True\napi_key = os.getenv('OMDB_API_KEY')\ni = os.getenv('OMDB_API_ID')\nurl = f'http://www.omdbapi.com/?i={i}&apikey={api_key}&t=squid+game'\n\nr = requests.get(url)\nprint(r.text)\n#&gt; {\"Title\":\"Squid Game\",\"Year\":\"2021–\",\"Rated\":\"TV-MA\",\"Released\":\"17 Sep 2021\",\"Runtime\":\"N/A\",\"Genre\":\"Action, Drama, Mystery\",\"Director\":\"N/A\",\"Writer\":\"N/A\",\"Actors\":\"Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\",\"Plot\":\"Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\",\"Language\":\"Korean, English, Urdu\",\"Country\":\"South Korea\",\"Awards\":\"Won 6 Primetime Emmys. 46 wins & 80 nominations total\",\"Poster\":\"https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\",\"Ratings\":[{\"Source\":\"Internet Movie Database\",\"Value\":\"8.0/10\"}],\"Metascore\":\"N/A\",\"imdbRating\":\"8.0\",\"imdbVotes\":\"482,476\",\"imdbID\":\"tt10919420\",\"Type\":\"series\",\"totalSeasons\":\"1\",\"Response\":\"True\"}\n\n\n\n\nOMDB_API_KEY=47xxxx\nOMDB_API_ID=ttxxxxx"
  },
  {
    "objectID": "ds_grammar.html",
    "href": "ds_grammar.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "1 데이터프레임\n\n펭귄 데이터셋\n\n2 데이터 문법\n\ndplyr\n\n3 그래프 문법\n\nggplot2\n\n4 표 문법\n\ngt"
  },
  {
    "objectID": "ds_grammar.html#urllib",
    "href": "ds_grammar.html#urllib",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "파머 펭귄 데이터셋 웹주소에서 데이터를 마치 로컬파일 데이터셋을 가져오듯이 동일한 방식으로 가져온다.\n\n코드from urllib.request import urlretrieve\nimport pandas as pd\n\nurl = 'https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv'\n\nurlretrieve(url, 'data/penguins.csv')\n\n# Read file into a DataFrame and print its head\n#&gt; ('data/penguins.csv', &lt;http.client.HTTPMessage object at 0x0000022199CEB4F0&gt;)\npenguins_df = pd.read_csv('data/penguins.csv', sep=',')\nprint(penguins_df.head())\n#&gt;    rowid species     island  ...  body_mass_g     sex  year\n#&gt; 0      1  Adelie  Torgersen  ...       3750.0    male  2007\n#&gt; 1      2  Adelie  Torgersen  ...       3800.0  female  2007\n#&gt; 2      3  Adelie  Torgersen  ...       3250.0  female  2007\n#&gt; 3      4  Adelie  Torgersen  ...          NaN     NaN  2007\n#&gt; 4      5  Adelie  Torgersen  ...       3450.0  female  2007\n#&gt; \n#&gt; [5 rows x 9 columns]"
  },
  {
    "objectID": "ds_grammar.html#requests",
    "href": "ds_grammar.html#requests",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "requests는 Python에서 HTTP 요청을 보내는 작업을 단순화하고, 사용자 친화적으로 만든 패키지다. GET, POST, DELETE, PUT 등의 다양한 HTTP 메소드를 사용하여 웹 서버와 통신할 수 있고, requests는 JSON 응답을 쉽게 파싱하고, 쿠키를 유지하며, 파일 업로드, HTTP 헤더 조작, SSL 인증 등의 복잡한 작업을 쉽게 처리할 수 있다.\nurllib는 Python의 표준 라이브러리 중 하나지만, 사용법이 다소 복잡하고 번거로운데 반해, requests는 인터페이스가 간결하고 직관적이어서 같은 작업을 더 쉽게 수행할 수 있다.\n\n\nrequests\nurllib\n\n\n\n\n코드import requests\n\nresponse = requests.get('https://r2bit.com')\n\nprint(response.status_code)\nprint(response.text)\n\n\n\n\n\n코드from urllib.request import urlopen\nresponse = urlopen('https://r2bit.com')\n\nprint(response.getcode())\nprint(response.read())"
  },
  {
    "objectID": "ds_grammar.html#beautifulsoup",
    "href": "ds_grammar.html#beautifulsoup",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "BeautifulSoup은 Python에서 HTML과 XML 문서를 파싱하기 위한 라이브러리다. 웹 스크래핑 작업에서 특히 유용하며, 복잡하고 잘 정돈되지 않은 웹 페이지에서 데이터를 쉽게 추출할 수 있다.\nBeautifulSoup은 문서를 트리 구조로 파싱하고, 이 트리를 통해 원하는 정보를 찾고, 수정하고, 네비게이트 할 수 있다. 예를 들어, HTML 문서에서 특정 태그를 찾거나, 특정 클래스 또는 ID를 가진 요소를 검색할 수 있다.\nrequests와 BeautifulSoup는 웹 스크래핑 작업에서 함께 사용되는 경우가 많다. 일반적으로 requests를 사용하여 웹페이지의 HTML을 가져오고, 그런 다음 BeautifulSoup을 사용하여 가져온 HTML을 파싱하고 원하는 정보를 추출하는 방식이다.\n\n\n웹사이트 제목\n링크\n\n\n\n\n코드import requests\nfrom bs4 import BeautifulSoup\n\nurl = 'https://r2bit.com'\n\nr = requests.get(url)\n\nhtml_doc = r.text\n\nsoup = BeautifulSoup(html_doc)\n\n# pretty_soup = soup.prettify()\nr2bit_title = soup.title\n\nprint(r2bit_title)\n#&gt; &lt;title&gt;한국 R 사용자회&lt;/title&gt;\n\n\n\n\n\n코드a_tags = soup.find_all('a')\n\nfor link in a_tags:\n    print(link.get('href'))\n#&gt; ./index.html\n#&gt; ./index.html\n#&gt; #\n#&gt; ./about.html\n#&gt; https://r2bit.com/chatGPT/\n#&gt; ./bitstat.html\n#&gt; ./packages.html\n#&gt; ./book.html\n#&gt; ./data.html\n#&gt; #\n#&gt; ./edutech.html\n#&gt; ./swc.html\n#&gt; ./learnr.html\n#&gt; ./training.html\n#&gt; ./blog.html\n#&gt; #\n#&gt; https://use-r.kr/\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://tidyverse-korea.github.io/seoul-R/\n#&gt; https://r2bit.com/seoul-r/\n#&gt; https://quarto.org/\n#&gt; ./contest.html\n#&gt; https://r2bit.com\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://github.com/bit2r/quarto\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; None\n#&gt; None\n#&gt; None\n#&gt; https://r2bit.com/bitSlide/slideshow/202210-hongik-v2\n#&gt; https://statkclee.github.io/ds-authoring/ds-world-student.html\n#&gt; None\n#&gt; None\n#&gt; https://www.sharingkorea.net/gboard/\n#&gt; https://r2bit.com/sen\n#&gt; https://choonghyunryu.github.io/workshop_lecture/\n#&gt; None\n#&gt; None\n#&gt; https://www.msit.go.kr/\n#&gt; #서울-r-미트업\n#&gt; #r-사용자회-회원-가입\n#&gt; https://www.meetup.com/seoul-r-meetup\n#&gt; https://r-community.org/usergroups/\n#&gt; https://r2bit.com/\n#&gt; https://use-r.kr/\n#&gt; https://r2bit.com/seoul-r\n#&gt; https://www.youtube.com/channel/UCW-epmIvjBEhhVXw_F0Nqbw\n#&gt; https://www.facebook.com/groups/tidyverse\n#&gt; https://korea-r-user-group.slack.com\n#&gt; https://forms.gle/ByJy34PkFdMJXHbe6\n#&gt; https://quarto.org/"
  },
  {
    "objectID": "ds_grammar.html#예제",
    "href": "ds_grammar.html#예제",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 예제",
    "text": "2.1 예제\n\n코드library(tidyverse)\n\ndataframe_df &lt;- tribble(~\"Name\", ~\"Age\",\n                        \"Alice\", 25,\n                        \"Bob\", 30,\n                        \"Charlie\", 35)\n\ngt::gt(dataframe_df)\n\n\n\n\n\n\nName\n      Age\n    \n\n\nAlice\n25\n\n\nBob\n30\n\n\nCharlie\n35\n\n\n\n\n\n\n6가지 JSON 파일 표현방법\n\nrecord: 각 레코드가 사전인 목록.\ncolumn: 키가 열 레이블인 중첩 딕셔너리.\nsplit: 인덱스, 열, 데이터가 포함된 딕셔너리.\nindex: 키가 인덱스 레이블인 중첩 딕셔너리.\nvalues: 그냥 값 배열.\ntable: 스키마와 데이터를 포함하는 중첩된 딕셔너리(Apache Arrow 형식과 상호 운용성을 목표로 하는 더 복잡한 형식).\n\n\n\nrecord\ncolumn\nsplit\nindex\nvalues\ntable\n\n\n\n[\n    {\"Name\": \"Alice\", \"Age\": 25},\n    {\"Name\": \"Bob\", \"Age\": 30},\n    {\"Name\": \"Charlie\", \"Age\": 35}\n]\n\n\n{\n    \"Name\": {\"0\": \"Alice\", \"1\": \"Bob\", \"2\": \"Charlie\"},\n    \"Age\": {\"0\": 25, \"1\": 30, \"2\": 35}\n}\n\n\n{\n    \"columns\": [\"Name\", \"Age\"],\n    \"index\": [0, 1, 2],\n    \"data\": [[\"Alice\", 25], [\"Bob\", 30], [\"Charlie\", 35]]\n}\n\n\n{\n    \"0\": {\"Name\": \"Alice\", \"Age\": 25},\n    \"1\": {\"Name\": \"Bob\", \"Age\": 30},\n    \"2\": {\"Name\": \"Charlie\", \"Age\": 35}\n}\n\n\n[\n    [\"Alice\", 25],\n    [\"Bob\", 30],\n    [\"Charlie\", 35]\n]\n\n\n{\n    \"schema\": {\n        \"fields\": [\n            {\"name\": \"index\", \"type\": \"integer\"},\n            {\"name\": \"Name\", \"type\": \"string\"},\n            {\"name\": \"Age\", \"type\": \"integer\"}\n        ],\n        \"primaryKey\": [\"index\"],\n        \"pandas_version\": \"0.20.0\"\n    },\n    \"data\": [\n        {\"index\": 0, \"Name\": \"Alice\", \"Age\": 25},\n        {\"index\": 1, \"Name\": \"Bob\", \"Age\": 30},\n        {\"index\": 2, \"Name\": \"Charlie\", \"Age\": 35}\n    ]\n}"
  },
  {
    "objectID": "ds_grammar.html#json-불러오기",
    "href": "ds_grammar.html#json-불러오기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 JSON 불러오기",
    "text": "2.2 JSON 불러오기\n다양한 형식으로 데이터프레임 파일을 저장했다면 다음 단계로 이를 파이썬에서 불러오는 방식은 json 패키지를 사용한다.\n\n코드import json\n\nwith open(\"data/json.json\") as json_file:\n    json_data = json.load(json_file)\n\nfor item in json_data:\n    if isinstance(item, dict):  # Check if the item is a dictionary\n        for k in item.keys():\n            print(k + ': ', item[k])\n    \n#&gt; Name:  Alice\n#&gt; Age:  25\n#&gt; Name:  Bob\n#&gt; Age:  30\n#&gt; Name:  Charlie\n#&gt; Age:  35"
  },
  {
    "objectID": "ds_grammar.html#pandas-불러오기",
    "href": "ds_grammar.html#pandas-불러오기",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 pandas 불러오기",
    "text": "2.3 pandas 불러오기\n\n코드import pandas as pd\n\njson_pd = pd.read_json(\"data/json.json\")\n\nprint(json_pd.describe())\n#&gt;         Age\n#&gt; count   3.0\n#&gt; mean   30.0\n#&gt; std     5.0\n#&gt; min    25.0\n#&gt; 25%    27.5\n#&gt; 50%    30.0\n#&gt; 75%    32.5\n#&gt; max    35.0"
  },
  {
    "objectID": "ds_grammar.html#omdb-api",
    "href": "ds_grammar.html#omdb-api",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n3.1 OMDB API",
    "text": "3.1 OMDB API\nOMDb API - The Open Movie Database에서 영화 API에 대한 다양한 정보를 얻을 수 있다.\n\n\nAPI 사양서\nAPI 시험\n직접 호출\nR API 호출\n파이썬 API 호출\n보안강화\n.env\n\n\n\nOMDb API - The Open Movie Database\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n코드library(httr)\nlibrary(tidyverse)\n\nsquid_game_req &lt;- glue::glue(\"http://www.omdbapi.com/\",\n           \"?i={Sys.getenv('OMDB_API_ID')}\",\n           \"&apikey={Sys.getenv('OMDB_API_KEY')}\",\n           \"&t=squid+game\")\n\nsquid_resp &lt;- GET(squid_game_req)\n\njsonlite::fromJSON(content(squid_resp, \"text\")) %&gt;% \n  enframe() %&gt;% \n  mutate(value = map_chr(value, 1))\n#&gt; # A tibble: 22 × 2\n#&gt;    name     value                                                               \n#&gt;    &lt;chr&gt;    &lt;chr&gt;                                                               \n#&gt;  1 Title    Squid Game                                                          \n#&gt;  2 Year     2021–                                                               \n#&gt;  3 Rated    TV-MA                                                               \n#&gt;  4 Released 17 Sep 2021                                                         \n#&gt;  5 Runtime  N/A                                                                 \n#&gt;  6 Genre    Action, Drama, Mystery                                              \n#&gt;  7 Director N/A                                                                 \n#&gt;  8 Writer   N/A                                                                 \n#&gt;  9 Actors   Lee Jung-jae, Park Hae-soo, Yasushi Iwaki                           \n#&gt; 10 Plot     Hundreds of cash-strapped players accept a strange invitation to co…\n#&gt; # ℹ 12 more rows\n\n\n\n\nimport requests\n\nurl = 'http://www.omdbapi.com/?i=ttxxxxx&apikey=47xxxx&t=squid+game'\n\nr = requests.get(url)\nprint(r.text)\n\n{\"Title\":\"Squid Game\",\"Year\":\"2021–\",\"Rated\":\"TV-MA\",\"Released\":\"17 Sep 2021\",\"Runtime\":\"N/A\",\"Genre\":\"Action, Drama, Mystery\",\"Director\":\"N/A\",\"Writer\":\"N/A\",\"Actors\":\"Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\",\"Plot\":\"Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\",\"Language\":\"Korean, English, Urdu\",\"Country\":\"South Korea\",\"Awards\":\"Won 6 Primetime Emmys. 46 wins & 80 nominations total\",\"Poster\":\"https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\",\"Ratings\":[{\"Source\":\"Internet Movie Database\",\"Value\":\"8.0/10\"}],\"Metascore\":\"N/A\",\"imdbRating\":\"8.0\",\"imdbVotes\":\"482,476\",\"imdbID\":\"tt10919420\",\"Type\":\"series\",\"totalSeasons\":\"1\",\"Response\":\"True\"}\njson_data = r.json()\n\n# Print each key-value pair in json_data\nfor k in json_data.keys():\n    print(k + ': ', json_data[k])\n    \nTitle:  Squid Game\nYear:  2021–\nRated:  TV-MA\nReleased:  17 Sep 2021\nRuntime:  N/A\nGenre:  Action, Drama, Mystery\nDirector:  N/A\nWriter:  N/A\nActors:  Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\nPlot:  Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\nLanguage:  Korean, English, Urdu\nCountry:  South Korea\nAwards:  Won 6 Primetime Emmys. 46 wins & 80 nominations total\nPoster:  https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\nRatings:  [{'Source': 'Internet Movie Database', 'Value': '8.0/10'}]\nMetascore:  N/A\nimdbRating:  8.0\nimdbVotes:  482,476\nimdbID:  tt10919420\nType:  series\ntotalSeasons:  1\nResponse:  True\n\n\n\n코드import requests\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n#&gt; True\napi_key = os.getenv('OMDB_API_KEY')\ni = os.getenv('OMDB_API_ID')\nurl = f'http://www.omdbapi.com/?i={i}&apikey={api_key}&t=squid+game'\n\nr = requests.get(url)\nprint(r.text)\n#&gt; {\"Title\":\"Squid Game\",\"Year\":\"2021–\",\"Rated\":\"TV-MA\",\"Released\":\"17 Sep 2021\",\"Runtime\":\"N/A\",\"Genre\":\"Action, Drama, Mystery\",\"Director\":\"N/A\",\"Writer\":\"N/A\",\"Actors\":\"Lee Jung-jae, Park Hae-soo, Yasushi Iwaki\",\"Plot\":\"Hundreds of cash-strapped players accept a strange invitation to compete in children's games. Inside, a tempting prize awaits with deadly high stakes. A survival game that has a whopping 45.6 billion-won prize at stake.\",\"Language\":\"Korean, English, Urdu\",\"Country\":\"South Korea\",\"Awards\":\"Won 6 Primetime Emmys. 46 wins & 80 nominations total\",\"Poster\":\"https://m.media-amazon.com/images/M/MV5BYWE3MDVkN2EtNjQ5MS00ZDQ4LTliNzYtMjc2YWMzMDEwMTA3XkEyXkFqcGdeQXVyMTEzMTI1Mjk3._V1_SX300.jpg\",\"Ratings\":[{\"Source\":\"Internet Movie Database\",\"Value\":\"8.0/10\"}],\"Metascore\":\"N/A\",\"imdbRating\":\"8.0\",\"imdbVotes\":\"482,476\",\"imdbID\":\"tt10919420\",\"Type\":\"series\",\"totalSeasons\":\"1\",\"Response\":\"True\"}\n\n\n\n\nOMDB_API_KEY=47xxxx\nOMDB_API_ID=ttxxxxx"
  },
  {
    "objectID": "git_github.html",
    "href": "git_github.html",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "GitHub는 클라우드 기반의 호스팅 서비스다. 이를 통해 사용자들은 자신들의 작업을 저장하고 추적할 수 있으며, 이를 ’버전 관리’라고도 부른다. 인터넷을 통해 요청에 따라 리소스를 제공하는데, 이 중 하나가 저장 공간이다. 이 덕분에 사용자는 로컬에 큰 파일들을 저장하지 않아도 된다. GitLab이나 BitBucket과 같이 GitHub와 유사한 서비스들도 있다라고 말할 수 있다.\n\nGitHub는 다양한 사용 사례를 가지고 있다.\n\n프로젝트를 저장하는 데 사용된다. 개발자는 GitHub를 이용해 코드를 안전하게 보관하고 필요할 때 언제든지 접근할 수 있다. 또한, GitHub는 프로젝트와 파일을 추적하는 기능도 제공한다. 이는 버전 관리 시스템의 일환으로, 코드의 이전 버전을 복구하거나, 특정 시점에서의 코드 변화를 확인하는 것이 가능하다.\nGitHub는 다른 사람들과 협업하는데도 사용된다. 다른 사용자와 함께 코드를 수정하고 개선하며, 이 과정에서 발생하는 모든 변경사항을 추적한다. 이로써, 팀 프로젝트를 진행하거나 여러 개발자가 동시에 같은 프로젝트에 참여하는 경우에 매우 유용하다.\nGitHub는 사회적 네트워크의 형태를 띠기도 한다. 개발자들은 서로의 프로젝트를 볼 수 있고, 코드를 공유하며 서로의 작업을 평가하고 피드백할 수 있다. 이는 코드의 질을 향상시키고, 새로운 아이디어나 해결책을 발견하는 데 도움을 준다.\nGitHub는 오픈 소스 프로젝트를 위한 플랫폼으로 널리 알려져 있다. 개발자들은 자신의 프로젝트를 공개적으로 공유하여, 다른 사람들이 그 프로젝트에 기여하거나, 자신의 프로젝트에서 사용할 수 있게 한다. 이로 인해, 전 세계의 개발자들이 자신의 아이디어와 코드를 공유하며, 서로 협력하는 글로벌 커뮤니티를 형성하게 된다라고 설명할 수 있다.\n\nGit은 리누스 토발즈가 개발한 분산 버젼 제어 관리 시스템이고, GitHub은 Git을 기반으로 한 협업 시스템이다.\n\n\n\n\n\n\n\n\nGit\nGitHub\n\n\n\n정의\n분산 버전 관리 시스템\n클라우드 기반 호스팅 서비스\n\n\n목적\n코드의 변경사항을 추적하고 협업\n코드 호스팅, 버전 관리, 협업, 오픈 소스 프로젝트 공유\n\n\n오프라인 작업\n예, 로컬에서 작동\n아니요, 인터넷 연결 필요\n\n\n협업\n로컬 네트워크를 통한 협업 가능\n웹 기반 서비스로 전세계 개발자들과 협업 가능\n\n\n인터페이스\n주로 커맨드라인 인터페이스\n웹 인터페이스와 그래픽 사용자 인터페이스 제공\n\n\n\nGit/GitHub은 로컬과 원격 저장소라는 차이만 존재하고 프로젝트에 대한 다음 정보를 담고 있다는 점에서 동일하다.\n\n파일(데이터, 디렉토리 포함)\n과거 변경이력(.git/)\n\n\n\n\n\n\nGitHub 저장소를 공개와 비공개로 정할 수 있다.\n\n\n\n1단계\n2단계\n3단계\n4단계\n5단계\n사용\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$ git clone https://github.com/statkclee/2015-02-25-seoul.git\nCloning into '2015-02-25-seoul'...\nUsername for 'https://github.com': tidyverse\nPassword for 'https://tidyverse@github.com':\nremote: Enumerating objects: 897, done.\nremote: Total 897 (delta 0), reused 0 (delta 0), pack-reused 897\nReceiving objects: 100% (897/897), 258.85 KiB | 9.59 MiB/s, done.\nResolving deltas: 100% (521/521), done.\n$ cd 2015-02-25-seoul\n$ ls\n_config.yml       DESIGN.md  img        index.html  LICENSE.md  requirements.txt  tools\nCUSTOMIZATION.md  FAQ.md     _includes  _layouts    README.md   setup\n\n\n\n\n“클론(Clone)”과 “포크(Fork)”는 Git과 GitHub에서 중요한 개념으로, 원격 저장소의 복사본을 만드는 방식에 차이가 있다.\n\n클론(Clone): 클론은 원격 저장소를 그대로 복사하여 로컬 시스템에 저장하는 것을 의미다. 이를 통해 원격 저장소의 모든 커밋 히스토리와 브랜치 등을 그대로 가져올 수 있습니다. 클론을 이용하면 로컬에서 작업을 시작하고, 그 결과를 다시 원격 저장소에 푸시하여 작업을 공유할 수 있고, 원본 저장소에 변경사항을 적용하려면 write 접근권한이 필요하다.\n포크(Fork): 포크는 GitHub에서 특정한 기능으로, 원격 저장소를 복사하여 사용자의 GitHub 계정 내에 새로운 원격 저장소를 생성한다. 이를 통해 원본 프로젝트를 자유롭게 수정하고 개선할 수 있고 포크된 저장소에서의 변경사항은 원본 저장소에 직접 반영되지 않으며, 사용자는 ’Pull Request’를 통해 원본 저장소에 변경사항을 제안할 수 있지만, 원본 저장소에 대한 write 접근권한은 필요하지 않다.\n\n\n\n\n\n\n\n\n\n클론(Clone)\n포크(Fork)\n\n\n\n정의\n다른 사람의 프로젝트를 로컬에 복제\n다른 사람의 프로젝트를 자신의 GitHub 계정에 복제\n\n\n목적\n프로젝트의 로컬 복사본을 만들어 작업하기\n원본 프로젝트에 대한 변경을 제안하거나 개선하기\n\n\n새로운 저장소 생성?\n아니오, 단순히 로컬에 복사본 생성\n예, 원본 프로젝트를 기반으로 새로운 리포지토리 생성\n\n\n협업\n원본 저장소에 대한 쓰기(write) 접근권한이 필요\n원본 저장소에 대한 쓰기(write) 접근권한이 없어도 가능\n\n\n\nGitHub의 “Issue”는 프로젝트에 대한 버그 리포트, 기능 요청, 질문, 또는 일반적인 토론을 위한 추적 도구입니다. 개발자들은 이슈를 사용하여 프로젝트의 특정 부분에 대해 의견을 주고받거나 문제점을 지적할 수 있다.\n\n문제 추적: 이슈는 프로젝트에서 발견된 버그나 개선점을 관리하고 추적하는 데 사용된다. 각 이슈에는 고유한 번호와 제목이 부여되어, 프로젝트의 특정 부분에 대한 질문이나 문제를 명확하게 지정하고 추적할 수 있다.\n협업 도구: 이슈는 프로젝트 참여자들 간의 의사소통 수단으로도 활용된다. 이슈를 통해 프로젝트 참여자들은 서로 대화를 나누고 문제 해결에 대한 아이디어를 공유할 수 있다.\n작업 관리: 이슈에는 라벨, 담당자, 마일스톤 등을 지정할 수 있어, 프로젝트의 작업을 효과적으로 관리할 수 있다. 라벨을 이용하면 이슈를 분류할 수 있고, 담당자를 지정하면 특정 이슈의 책임자를 명확히 할 수 있다. 마일스톤을 설정하면 이슈를 특정 목표와 연결시킬 수 있다.\n프로젝트 상태 추적: 이슈는 ‘열림’ 또는 ‘닫힘’ 상태를 가진다. 이슈가 해결되면 ‘닫힘’ 상태로 변경되어, 해당 이슈가 처리되었음을 명확하게 표시할 수 있고, 이를 통해 프로젝트의 전체적인 진행 상태를 쉽게 파악할 수 있다.\n\n풀요청(PR, ‘Pull Request’)는 GitHub의 핵심 기능 중 하나로, 사용자가 자신이 수정 또는 개선한 코드를 원본 프로젝트에 반영하고자 할 때 사용하는 기능이다. Pull Request를 통해 사용자는 원본 프로젝트의 소유자 또는 관리자에게 자신의 변경사항을 검토하고 병합해달라는 요청을 보낼 수 있다.\n\n포크(Fork): 원본 저장소를 자신의 GitHub 계정으로 포크(fork)한다. 원본 저장소의 전체 복사본이 자신의 계정에 생성된다.\nClone and Create a New Branch: 포크된 저장소를 자신의 로컬 시스템으로 클론(clone)한 후, 새로운 브랜치를 만든다. 이 브랜치에서 변경사항을 작업하면 원본 프로젝트의 코드를 안전하게 보호할 수 있다.\nMake Changes and Commit: 필요한 변경을 만든 후, 이를 커밋(commit)합니다. 커밋 메시지에는 작업 내용을 명확하게 설명해야 한다.\nPush: 변경사항을 자신의 GitHub 포크 저장소로 푸시(push)한다.\nCreate a Pull Request: GitHub 페이지에서 원본 저장소를 방문하여 “New pull request” 버튼을 클릭한다. 변경하고자 하는 브랜치를 선택한 후, Pull Request의 세부사항을 작성하고 “Create pull request” 버튼을 클릭하여 Pull Request를 제출한다.\n원본 저장소의 소유자 또는 관리자는 제출된 Pull Request를 검토하고, 필요하다면 논의를 진행한다. 만약 모든 것이 순조롭다면, 원본 저장소의 관리자는 Pull Request를 수락하고 병합(merge)하여 변경사항을 원본 프로젝트에 반영하게 된다."
  },
  {
    "objectID": "git_github.html#사용사례",
    "href": "git_github.html#사용사례",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "GitHub는 다양한 사용 사례를 가지고 있다.\n\n프로젝트를 저장하는 데 사용된다. 개발자는 GitHub를 이용해 코드를 안전하게 보관하고 필요할 때 언제든지 접근할 수 있다. 또한, GitHub는 프로젝트와 파일을 추적하는 기능도 제공한다. 이는 버전 관리 시스템의 일환으로, 코드의 이전 버전을 복구하거나, 특정 시점에서의 코드 변화를 확인하는 것이 가능하다.\nGitHub는 다른 사람들과 협업하는데도 사용된다. 다른 사용자와 함께 코드를 수정하고 개선하며, 이 과정에서 발생하는 모든 변경사항을 추적한다. 이로써, 팀 프로젝트를 진행하거나 여러 개발자가 동시에 같은 프로젝트에 참여하는 경우에 매우 유용하다.\nGitHub는 사회적 네트워크의 형태를 띠기도 한다. 개발자들은 서로의 프로젝트를 볼 수 있고, 코드를 공유하며 서로의 작업을 평가하고 피드백할 수 있다. 이는 코드의 질을 향상시키고, 새로운 아이디어나 해결책을 발견하는 데 도움을 준다.\nGitHub는 오픈 소스 프로젝트를 위한 플랫폼으로 널리 알려져 있다. 개발자들은 자신의 프로젝트를 공개적으로 공유하여, 다른 사람들이 그 프로젝트에 기여하거나, 자신의 프로젝트에서 사용할 수 있게 한다. 이로 인해, 전 세계의 개발자들이 자신의 아이디어와 코드를 공유하며, 서로 협력하는 글로벌 커뮤니티를 형성하게 된다라고 설명할 수 있다."
  },
  {
    "objectID": "git_github.html#gitgithub-비교",
    "href": "git_github.html#gitgithub-비교",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "Git은 리누스 토발즈가 개발한 분산 버젼 제어 관리 시스템이고, GitHub은 Git을 기반으로 한 협업 시스템이다.\n\n\n\n\n\n\n\n\nGit\nGitHub\n\n\n\n정의\n분산 버전 관리 시스템\n클라우드 기반 호스팅 서비스\n\n\n목적\n코드의 변경사항을 추적하고 협업\n코드 호스팅, 버전 관리, 협업, 오픈 소스 프로젝트 공유\n\n\n오프라인 작업\n예, 로컬에서 작동\n아니요, 인터넷 연결 필요\n\n\n협업\n로컬 네트워크를 통한 협업 가능\n웹 기반 서비스로 전세계 개발자들과 협업 가능\n\n\n인터페이스\n주로 커맨드라인 인터페이스\n웹 인터페이스와 그래픽 사용자 인터페이스 제공"
  },
  {
    "objectID": "git_github.html#github-저장소",
    "href": "git_github.html#github-저장소",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "Git/GitHub은 로컬과 원격 저장소라는 차이만 존재하고 프로젝트에 대한 다음 정보를 담고 있다는 점에서 동일하다.\n\n파일(데이터, 디렉토리 포함)\n과거 변경이력(.git/)"
  },
  {
    "objectID": "git_github.html#비-공개-저장소",
    "href": "git_github.html#비-공개-저장소",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "GitHub 저장소를 공개와 비공개로 정할 수 있다."
  },
  {
    "objectID": "git_github.html#pat-설정",
    "href": "git_github.html#pat-설정",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "1단계\n2단계\n3단계\n4단계\n5단계\n사용\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$ git clone https://github.com/statkclee/2015-02-25-seoul.git\nCloning into '2015-02-25-seoul'...\nUsername for 'https://github.com': tidyverse\nPassword for 'https://tidyverse@github.com':\nremote: Enumerating objects: 897, done.\nremote: Total 897 (delta 0), reused 0 (delta 0), pack-reused 897\nReceiving objects: 100% (897/897), 258.85 KiB | 9.59 MiB/s, done.\nResolving deltas: 100% (521/521), done.\n$ cd 2015-02-25-seoul\n$ ls\n_config.yml       DESIGN.md  img        index.html  LICENSE.md  requirements.txt  tools\nCUSTOMIZATION.md  FAQ.md     _includes  _layouts    README.md   setup"
  },
  {
    "objectID": "git_github.html#클론과-포크",
    "href": "git_github.html#클론과-포크",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "“클론(Clone)”과 “포크(Fork)”는 Git과 GitHub에서 중요한 개념으로, 원격 저장소의 복사본을 만드는 방식에 차이가 있다.\n\n클론(Clone): 클론은 원격 저장소를 그대로 복사하여 로컬 시스템에 저장하는 것을 의미다. 이를 통해 원격 저장소의 모든 커밋 히스토리와 브랜치 등을 그대로 가져올 수 있습니다. 클론을 이용하면 로컬에서 작업을 시작하고, 그 결과를 다시 원격 저장소에 푸시하여 작업을 공유할 수 있고, 원본 저장소에 변경사항을 적용하려면 write 접근권한이 필요하다.\n포크(Fork): 포크는 GitHub에서 특정한 기능으로, 원격 저장소를 복사하여 사용자의 GitHub 계정 내에 새로운 원격 저장소를 생성한다. 이를 통해 원본 프로젝트를 자유롭게 수정하고 개선할 수 있고 포크된 저장소에서의 변경사항은 원본 저장소에 직접 반영되지 않으며, 사용자는 ’Pull Request’를 통해 원본 저장소에 변경사항을 제안할 수 있지만, 원본 저장소에 대한 write 접근권한은 필요하지 않다.\n\n\n\n\n\n\n\n\n\n클론(Clone)\n포크(Fork)\n\n\n\n정의\n다른 사람의 프로젝트를 로컬에 복제\n다른 사람의 프로젝트를 자신의 GitHub 계정에 복제\n\n\n목적\n프로젝트의 로컬 복사본을 만들어 작업하기\n원본 프로젝트에 대한 변경을 제안하거나 개선하기\n\n\n새로운 저장소 생성?\n아니오, 단순히 로컬에 복사본 생성\n예, 원본 프로젝트를 기반으로 새로운 리포지토리 생성\n\n\n협업\n원본 저장소에 대한 쓰기(write) 접근권한이 필요\n원본 저장소에 대한 쓰기(write) 접근권한이 없어도 가능"
  },
  {
    "objectID": "git_github.html#이슈issue",
    "href": "git_github.html#이슈issue",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "GitHub의 “Issue”는 프로젝트에 대한 버그 리포트, 기능 요청, 질문, 또는 일반적인 토론을 위한 추적 도구입니다. 개발자들은 이슈를 사용하여 프로젝트의 특정 부분에 대해 의견을 주고받거나 문제점을 지적할 수 있다.\n\n문제 추적: 이슈는 프로젝트에서 발견된 버그나 개선점을 관리하고 추적하는 데 사용된다. 각 이슈에는 고유한 번호와 제목이 부여되어, 프로젝트의 특정 부분에 대한 질문이나 문제를 명확하게 지정하고 추적할 수 있다.\n협업 도구: 이슈는 프로젝트 참여자들 간의 의사소통 수단으로도 활용된다. 이슈를 통해 프로젝트 참여자들은 서로 대화를 나누고 문제 해결에 대한 아이디어를 공유할 수 있다.\n작업 관리: 이슈에는 라벨, 담당자, 마일스톤 등을 지정할 수 있어, 프로젝트의 작업을 효과적으로 관리할 수 있다. 라벨을 이용하면 이슈를 분류할 수 있고, 담당자를 지정하면 특정 이슈의 책임자를 명확히 할 수 있다. 마일스톤을 설정하면 이슈를 특정 목표와 연결시킬 수 있다.\n프로젝트 상태 추적: 이슈는 ‘열림’ 또는 ‘닫힘’ 상태를 가진다. 이슈가 해결되면 ‘닫힘’ 상태로 변경되어, 해당 이슈가 처리되었음을 명확하게 표시할 수 있고, 이를 통해 프로젝트의 전체적인 진행 상태를 쉽게 파악할 수 있다."
  },
  {
    "objectID": "git_github.html#풀-요청pull-request",
    "href": "git_github.html#풀-요청pull-request",
    "title": "챗GPT 데이터 사이언스",
    "section": "",
    "text": "풀요청(PR, ‘Pull Request’)는 GitHub의 핵심 기능 중 하나로, 사용자가 자신이 수정 또는 개선한 코드를 원본 프로젝트에 반영하고자 할 때 사용하는 기능이다. Pull Request를 통해 사용자는 원본 프로젝트의 소유자 또는 관리자에게 자신의 변경사항을 검토하고 병합해달라는 요청을 보낼 수 있다.\n\n포크(Fork): 원본 저장소를 자신의 GitHub 계정으로 포크(fork)한다. 원본 저장소의 전체 복사본이 자신의 계정에 생성된다.\nClone and Create a New Branch: 포크된 저장소를 자신의 로컬 시스템으로 클론(clone)한 후, 새로운 브랜치를 만든다. 이 브랜치에서 변경사항을 작업하면 원본 프로젝트의 코드를 안전하게 보호할 수 있다.\nMake Changes and Commit: 필요한 변경을 만든 후, 이를 커밋(commit)합니다. 커밋 메시지에는 작업 내용을 명확하게 설명해야 한다.\nPush: 변경사항을 자신의 GitHub 포크 저장소로 푸시(push)한다.\nCreate a Pull Request: GitHub 페이지에서 원본 저장소를 방문하여 “New pull request” 버튼을 클릭한다. 변경하고자 하는 브랜치를 선택한 후, Pull Request의 세부사항을 작성하고 “Create pull request” 버튼을 클릭하여 Pull Request를 제출한다.\n원본 저장소의 소유자 또는 관리자는 제출된 Pull Request를 검토하고, 필요하다면 논의를 진행한다. 만약 모든 것이 순조롭다면, 원본 저장소의 관리자는 Pull Request를 수락하고 병합(merge)하여 변경사항을 원본 프로젝트에 반영하게 된다."
  },
  {
    "objectID": "git_github.html#버전과-버전제어",
    "href": "git_github.html#버전과-버전제어",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.1 버전과 버전제어",
    "text": "2.1 버전과 버전제어\n버전(Version)이란, 특정 시점에서 파일의 내용을 지칭한다. 이는 소프트웨어나 프로그램, 심지어 문서 등 어떤 유형의 파일에서도 발생할 수 있으며, 파일에 일어난 변화를 시간적 순서에 따라 추적하고 관리하는 데 유용하다. 즉, 특정 시점의 파일 내용과 그와 연관된 정보들을 총체적으로 포함한 상태를 말한다. 이렇게 버전을 통해 파일의 변경사항을 관리하고 추적함으로써, 이전 상태로 롤백하거나 특정 시점의 상태를 참조할 수 있다는 장점이 있다.\n버전에는 파일의 내용 외에도 메타데이터라 불리는 추가 정보가 포함될 수 있다. 이 메타데이터에는 파일 작성자, 파일이 위치한 곳, 파일 유형, 마지막으로 저장된 시간 등이 포함될 수 있다. 이러한 메타데이터는 버전 관리 시스템에서 파일의 변화를 효과적으로 추적하고 이해하는 데 중요한 역할을 한다.\n버전 제어(Version Control)는 문서, 프로그램, 디렉토리 등의 변경사항을 관리하기 위한 시스템과 과정을 총체적으로 지칭한다. 이는 시간이 지나면서 변화하는 어떤 것에든, 또는 공유해야 하는 어떤 것에든 유용하게 사용될 수 있다. 버전 제어는 프로젝트의 변화를 체계적으로 관리하고 추적하는 동시에, 효과적인 협업을 가능하게 하여 개발자들은 보다 안정적이고 효율적인 개발 환경을 구축하고 유지할 수 있다.\n버전 제어 시스템을 사용하면, 파일이나 프로젝트의 각 버전을 명확히 식별하고 추적할 수 있다. 이는 특정 시점의 버전으로 롤백하거나, 다른 버전과의 차이점을 비교하고 병합하는 것을 가능하게 하고, 여러 사용자가 동일한 프로젝트에 동시에 작업할 경우, 각자의 작업을 분리하여 관리하고, 이후 안전하게 병합하는 작업을 가능케 한다.\n버전 제어가 중요한 이유를 다음과 같이 요약할 수 있다.\n\n변경사항 추적: 버전 제어 시스템을 사용하면 프로젝트에 대한 수정사항을 시간에 따라 추적할 수 있다. 이는 단순히 무엇이 변경되었는지만 아니라 누가 그 변경사항을 만들었는지, 왜 만들었는지에 대한 정보도 포함한다. 만약 에러가 발생하면, 문제가 언제 어떻게 발생했는지를 확인할 수 있다.\n협업: 팀 환경에서는 여러 사람이 동일한 프로젝트에 참여한다. 버전 제어가 없으면 팀원들이 서로의 변경사항을 덮어쓰게 되어 혼란을 초래하고 작업을 잃어버릴 수 있다. 버전 제어를 사용하면 여러 사람이 동시에 프로젝트에 작업을 하더라도 작업을 잃어버리거나 덮어쓰는 일 없이 작업을 할 수 있다.\n실수 되돌리기: 실수를 하거나 버그를 도입한 경우, 버전 제어를 통해 코드베이스를 이전 상태로 되돌릴 수 있다. 이는 작은 버그가 큰 영향을 미칠 수 있는 중요한 시스템에서 생명을 구할 수 있는 도구다.\n백업 및 복원: 버전 제어 시스템은 모든 변경사항의 복사본을 유지함으로써 백업의 역할을 한다. 데이터를 잃어버리거나 작업이 손상된 경우, 이전 버전의 작업을 복원할 수 있다.\n실험: 버전 제어를 사용하면, 개발자들은 새로운 기능이나 아이디어를 실험하기 위해 브랜치를 만들어 기본 코드베이스에 방해를 주지 않고 작업할 수 있다. 새로운 아이디어가 테스트되고 승인되면, 이를 메인 코드베이스로 다시 병합할 수 있다.\n\n\n2.1.1 Git 장점\nGit은 컴퓨터 프로그래밍 및 데이터 프로젝트를 위한 인기 있는 버전 제어 시스템으로 2005년에 리누스 토발즈가 개발했으며, 그의 주요 목표 중 하나는 효율성, 데이터 무결성, 독립적인 작업의 지원 등을 기반으로 한 대형 프로젝트를 위한 완전히 분산된 시스템을 만드는 것이였다. Git은 오픈소스로 소스 코드가 공개적으로 이용 가능하여 누구나 Git의 코드를 가져와서 필요에 따라 수정하거나 개선할 수 있다. Git은 매우 확장 가능한 도구로 작은 프로젝트에서부터 대규모 프로젝트까지 다양한 크기와 복잡성의 프로젝트에서 사용할 수 있다. Git과 GitHub은 다르지만, 함께 사용된다. Git은 버전 제어 시스템이며, 반면에 GitHub는 Git을 기반으로 한 웹 기반의 호스팅 서비스로 GitHub을 통해 Git 기능을 활용하면서 코드를 온라인으로 공유하고 협업하는 기능을 추가적으로 제공한다.\n\n2.1.2 Git 설치\n$ git --version\ngit version 2.30.2"
  },
  {
    "objectID": "git_github.html#git-장점",
    "href": "git_github.html#git-장점",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 Git 장점",
    "text": "2.2 Git 장점\nGit은 컴퓨터 프로그래밍 및 데이터 프로젝트를 위한 인기 있는 버전 제어 시스템으로 2005년에 리누스 토발즈가 개발했으며, 그의 주요 목표 중 하나는 효율성, 데이터 무결성, 독립적인 작업의 지원 등을 기반으로 한 대형 프로젝트를 위한 완전히 분산된 시스템을 만드는 것이였다. Git은 오픈소스로 소스 코드가 공개적으로 이용 가능하여 누구나 Git의 코드를 가져와서 필요에 따라 수정하거나 개선할 수 있다. Git은 매우 확장 가능한 도구로 작은 프로젝트에서부터 대규모 프로젝트까지 다양한 크기와 복잡성의 프로젝트에서 사용할 수 있다. Git과 GitHub은 다르지만, 함께 사용된다. Git은 버전 제어 시스템이며, 반면에 GitHub는 Git을 기반으로 한 웹 기반의 호스팅 서비스로 GitHub을 통해 Git 기능을 활용하면서 코드를 온라인으로 공유하고 협업하는 기능을 추가적으로 제공한다."
  },
  {
    "objectID": "git_github.html#git-설치",
    "href": "git_github.html#git-설치",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 Git 설치",
    "text": "2.3 Git 설치\n$ git --version\ngit version 2.30.2"
  },
  {
    "objectID": "git_github.html#git-작업흐름",
    "href": "git_github.html#git-작업흐름",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.2 Git 작업흐름",
    "text": "2.2 Git 작업흐름\n실제 환경에서는 브랜치 생성, 병합, 충돌 해결 등 추가적인 단계가 있지만, 매우 기본적인 Git 작업 흐름은 다음과 같다.\n\n작업 영역(프로젝트 디렉토리)에서 변경사항 생성: 로컬 시스템에서 작업을 진행하면서 파일을 수정하거나 새로 생성한다.\n변경사항을 준비영역 추가: git add 명령어를 사용하여 작업 영역의 변경사항을 준비영역(Staging Area)에 추가를 통해 커밋될 변경사항이 준비된다.\n준비영역 변경사항을 로컬 저장소에 커밋: git commit 명령어를 사용하여 메세지 -m과 함께 준비영역 변경사항을 로컬 저장소에 커밋한다. 이 단계를 통해 변경사항이 .git 저장소에 히스토리에 기록된다.\n커밋된 변경사항을 원격 저장소에 푸시: git push 명령어를 사용하여 로컬 저장소의 커밋된 변경사항을 원격 저장소에 푸시한다. 이 작업을 통해 다른 개발자들이 변경사항을 볼 수 있게 된다.\n\n\n\n\n\nsequenceDiagram\n    participant W as 작업 디렉토리&lt;br&gt; Working Directory\n    participant I as 준비구역 &lt;br&gt; Staging Area\n    participant LR as 로컬 저장소 &lt;br&gt; Local Repository\n    participant RR as 원격 저장소 &lt;br&gt; Remote Repository\n    W-&gt;&gt;I: git add &lt;br/&gt; (준비구역 변경)\n    Note over W,I: Staging Changes\n    I-&gt;&gt;LR: git commit &lt;br/&gt; (로컬 변경)\n    Note over I,LR: Committing Changes\n    LR-&gt;&gt;RR: git push &lt;br/&gt; (원격 변경)\n    Note over LR,RR: Pushing Changes"
  },
  {
    "objectID": "git_github.html#git-diff",
    "href": "git_github.html#git-diff",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.3 git diff\n",
    "text": "2.3 git diff\n\ngit diff 명령어는 Git에서 파일 변경사항을 확인할 때 사용한다. 특정 파일의 수정 내역, 두 커밋 사이의 차이점, 브랜치 간 차이점 등을 확인할 수 있고, git diff를 통해 여러가지 환경과 상황에서 파일 변경사항을 확인하는 데 도움이 된다.\n\n2.3.1 디렉토리 &lt;—&gt; 준비영역\n아직 스테이징하지 않은 변경사항을 보여준다.\n$ git diff\n\n\n\n\ngraph LR\n    subgraph \"Case: Changes in Working Directory\"\n        A[Working Directory] -- \"git diff\" --&gt; B[\"Shows unstaged changes\"]\n    end\n\n\n\n\n\n\n2.3.2 준비영역 &lt;—&gt; 로컬 저장소\n준비영역과 마지막 커밋 사이의 변경사항 확인하는 경우로 다음 커밋에 반영될 변경사항(즉, 스테이징된 변경사항)을 보여준다.\n$ git diff --staged\n\n\n\n\ngraph LR\n    subgraph \"Case: Changes in Staging Area\"\n        C[Staging Area] -- \"git diff --staged\" --&gt; D[\"Shows changes to be committed\"]\n    end\n\n\n\n\n\n\n2.3.3 커밋 &lt;—&gt; 커밋\n두 개의 커밋 사이의 변경사항을 확인하는데 와  사이의 변경사항을 보여준다.\n$ git diff &lt;commit_id1&gt;..&lt;commit_id2&gt;\n\n\n\n\ngraph TB\n    subgraph \"Case: Changes between Commits\"\n        E[Commit1] -- \"git diff commit1..commit2\" --&gt; F[\"Shows changes between two commits\"]\n    end\n\n\n\n\n\n\n2.3.4 브랜치 &lt;—&gt; 브랜치\n두 개의 브랜치 사이의 변경사항을 확인하는데 와  사이의 변경사항을 보여준다.\n$ git diff &lt;branch_name1&gt;..&lt;branch_name2&gt;\n\n\n\n\ngraph TB\n    subgraph \"Case: Changes between Branches\"\n        G[Branch1] -- \"git diff branch1..branch2\" --&gt; H[\"Shows changes between two branches\"]\n    end\n\n\n\n\n\n\n\n\n\n\n\ngit diff 독해\n\n\n\n\n\n$ git diff file1.md\ndiff --git a/file1 b/file1\nindex 3f0e8a9..9cce8e0 100644\n--- a/file1\n+++ b/file1\n@@ -1,4 +1,4 @@\n-this is the original text\n+this is the modified text\n this is an unchanged line\n-this is another original line\n+this is another modified line\n\n--- a/file1과 +++ b/file1: 이 줄들은 비교되는 파일들을 나타낸다. a/는 변경 전의 파일을, b/는 변경 후의 파일을 의미한다.\n@@ -1,4 +1,4 @@: 이는 “헌크 헤더(hunk header)”라고 부르며, 변경되는 행들의 위치와 범위를 나타냅니다. -1,4는 원본 파일에서 1번째 줄에서 시작해서 4줄이 변경되었음을 의미하고, +1,4는 수정된 파일에서 1번째 줄에서 시작해서 4줄이 변경되었음을 의미한다.\n-this is the original text와 +this is the modified text: -로 시작하는 줄은 삭제된 줄을, +로 시작하는 줄은 추가된 줄을 나타낸다."
  },
  {
    "objectID": "git_github.html#git-log",
    "href": "git_github.html#git-log",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.4 git log\n",
    "text": "2.4 git log\n\ngit log 명령은 커밋 이력을 확인하는 데 사용된다. 기본적인 사용법은 git log 혹은 최근 3개를 원하면 git log -n 3를 입력하면 된다. 가장 최근의 커밋부터 시작하여 커밋들이 역순으로 출력된다.\n\n\n$ git diff file1.md\ndiff --git a/file1 b/file1\nindex 3f0e8a9..9cce8e0 100644\n--- a/file1\n+++ b/file1\n@@ -1,4 +1,4 @@\n-this is the original text\n+this is the modified text\n this is an unchanged line\n-this is another original line\n+this is another modified line\n\n--- a/file1과 +++ b/file1: 이 줄들은 비교되는 파일들을 나타낸다. a/는 변경 전의 파일을, b/는 변경 후의 파일을 의미한다.\n@@ -1,4 +1,4 @@: 이는 “헌크 헤더(hunk header)”라고 부르며, 변경되는 행들의 위치와 범위를 나타냅니다. -1,4는 원본 파일에서 1번째 줄에서 시작해서 4줄이 변경되었음을 의미하고, +1,4는 수정된 파일에서 1번째 줄에서 시작해서 4줄이 변경되었음을 의미한다.\n-this is the original text와 +this is the modified text: -로 시작하는 줄은 삭제된 줄을, +로 시작하는 줄은 추가된 줄을 나타낸다.\n\n\n\n\n\n\n\n\ngit log 독해\n\n\n\n\n\n$ git log -n 3\ncommit 5a6dcd1b2a7e495b7e05641918f3d4f9d5ae8165 (HEAD -&gt; main, origin/main, origin/HEAD)\nAuthor: Your Name &lt;yourname@example.com&gt;\nDate:   Fri Jun 30 13:00:00 2023 -0700\n\n    Fix bug in calculation function\n\ncommit d6b4c88f2dd6214d5f618b9a22f0e104b3357e68\nAuthor: Your Name &lt;yourname@example.com&gt;\nDate:   Thu Jun 29 13:00:00 2023 -0700\n\n    Add new calculation function\n\ncommit 0d8d2e64a2aeb9752714b243624969711bb8f1f3\nAuthor: Your Name &lt;yourname@example.com&gt;\nDate:   Wed Jun 28 13:00:00 2023 -0700\n\n    Initial commit\n\ncommit 5a6dcd1b2a7e495b7e05641918f3d4f9d5ae8165: 커밋의 SHA-1 해시로 커밋을 식별하는 유일한 ID다.\nAuthor: Your Name &lt;yourname@example.com&gt;: 커밋을 수행한 사람 정보\nDate: Fri Jun 30 13:00:00 2023 -0700: 커밋이 수행된 시간\nFix bug in calculation function: 커밋 메시지로 커밋이 수행한 변경사항을 요약한다."
  },
  {
    "objectID": "git_github.html#git-show",
    "href": "git_github.html#git-show",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.5 git show\n",
    "text": "2.5 git show\n\ngit show 명령은 특정 커밋에 대한 정보를 표시한다. git show index.md 명령은 index.md 파일에 대한 최신 커밋의 세부 정보를 보여주고, 그 커밋에서 파일이 어떻게 변경되었는지를 보여준다.\n\n\n$ git show index.md\ncommit 63450dfbda1a560b9a6e5c3a78db5271b6f6e744\nAuthor: Your Name &lt;yourname@example.com&gt;\nDate:   Fri Jun 30 13:00:00 2023 -0700\n\n    Update index.md\n\ndiff --git a/index.md b/index.md\nindex 7a8bca5..97c5076 100644\n--- a/index.md\n+++ b/index.md\n@@ -1,4 +1,4 @@\n # Hello, World!\n \n-This is the original content.\n+This is the updated content.\n\n\n\ncommit 63450dfbda1a560b9a6e5c3a78db5271b6f6e744: index.md 파일을 마지막으로 수정한 커밋의 해시값이다.\n\nAuthor: Your Name &lt;yourname@example.com&gt;: 해당 커밋의 저자다.\n\nDate: Fri Jun 30 13:00:00 2023 -0700: 해당 커밋이 만들어진 날짜와 시간이다.\n\nUpdate index.md: 커밋 메시지다.\n\n그 다음은 diff 정보로 커밋이 해당 파일을 어떻게 변경했는지 보여준다.\n\n\ndiff --git a/index.md b/index.md: 변경을 비교하는 두 파일의 이름이다.\n\n--- a/index.md +++ b/index.md: 비교를 위해 사용하는 두 파일의 버전이다.\n\n@@ -1,4 +1,4 @@: 변경이 발생한 라인의 범위를 나타낸다. 첫 번째 파일의 1행에서 4행 사이와 두 번째 파일의 1행에서 4행 사이에서 변경이 있었다.\n\n-This is the original content.: 첫 번째 파일에서 제거된 줄이다.\n\n+This is the updated content.: 두 번째 파일에서 추가된 줄이다.\n\n\n\n\n2.5.1 git diff/log/show 비교\ngit log, git show, git diff는 Git에서 제공하는 기능 중 일부이며, 각각 다른 역할을 수행한다.\n\n\n\n\n\n\n\n명령어\n설명\n출력결과\n\n\n\ngit log\n커밋 히스토리를 조회하는 명령.\n가장 최근의 커밋부터 시작하여 역순으로 모든 커밋을 보여주고, 각 커밋의 해시, 작성자 정보, 날짜 및 커밋 메시지가 포함된다.\n\n\ngit show\n특정 커밋의 상세 정보를 보여주는 명령.\n해당 커밋에서 이루어진 변경사항을 보여주고, 커밋 정보와 git diff 명령의 출력이 모두 포함된다.\n\n\ngit diff\n두 커밋 혹은 작업 공간과 스테이징 영역 사이의 차이를 보여주는 명령.\n작업 공간에 있는 현재 변경사항과 스테이징 영역 사이의 차이를 보여주고, 두 커밋의 해시를 지정하여 해당 커밋들 사이의 차이를 보는 것도 가능하다."
  },
  {
    "objectID": "git_github.html#undo-실행취소",
    "href": "git_github.html#undo-실행취소",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.6 Undo 실행취소",
    "text": "2.6 Undo 실행취소\nGit에서는 몇 가지 방법으로 변경사항을 취소하거나 이전 상태로 되돌릴 수 있다. HEAD~1는 마지막 커밋을 HEAD~2는 마지막에서 두 번째 커밋을 지칭한다.\n\n작업 디렉토리의 변경 사항 되돌리기: 만약 작업 디렉토리에서 변경한 내용을 되돌리고 싶다면, git checkout -- &lt;file&gt; 명령어를 사용할 수 있다. 이것은 지정된 파일의 변경사항을 마지막 커밋으로 되돌린다. 예를 들어, index.md라는 파일의 변경을 되돌리려면 git checkout -- index.md를 실행하면 된다.\n스테이징된 변경 사항 되돌리기: 변경사항을 스테이징했지만, 이를 되돌리고 싶다면 git reset HEAD &lt;file&gt; 명령어를 사용할 수 있다. 이 명령어는 지정된 파일의 스테이징된 변경사항을 되돌린다. 예를 들어, index.md라는 파일의 스테이징을 취소하려면 git reset HEAD index.md를 실행하면 됩니다.\n마지막 커밋 되돌리기: 만약 최근의 커밋을 취소하고 작업 디렉토리와 스테이지를 그 상태로 유지하려면, git reset --soft HEAD~1 명령어를 사용할 수 있다. 이 명령은 마지막 커밋을 취소하지만 변경 사항은 스테이징된 상태로 남아 있게 된다.\n마지막 커밋 완전히 취소하기: 최근의 커밋을 완전히 취소하고 그 변경사항을 모두 버리려면 git reset --hard HEAD~1 명령어를 사용할 수 있다. 이 명령은 마지막 커밋을 삭제하고 그 변경사항을 작업 디렉토리에서도 삭제한다. 이 명령은 조심스럽게 사용해야 하며, 되돌릴 수 없다.\n\n$ echo \"Original Content\" &gt; index.md\n$ git add index.md\n$ git commit -m \"Initial commit\"\n\n2.6.1 작업 디렉토리의 변경 사항 되돌리기\n먼저 현재 작업 디렉토리에서 index.md 파일에 수정작업을 가하자.\n$ echo \"Modified Content\" &gt; index.md\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   index.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ngit checkout -- 명령어로 실행취소(undo) 한다.\n$ git checkout -- index.md\n$ cat index.md\nOriginal Content\n\n2.6.2 스테이징된 변경 사항 되돌리기\ngit add index.md 명령어로 작업디렉토리에서 변경한 작업을 준비단계 스테이징 영역으로 옮긴다.\n$ echo \"Modified Content\" &gt; index.md\n$ git add index.md\n$ git status\n\nOn branch main\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n        modified:   index.md\ngit reset HEAD 명령어로 준비영역에 있던 변경사항을 다시 작업 디렉토리로 회수한다.\n$ git reset HEAD index.md\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   index.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n2.6.3 마지막 커밋 되돌리기\ngit add, git commit 명령어로 로컬 .git 저장소에 변경사항을 기록한다.\n$ echo \"New Content\" &gt; index.md\n$ git add index.md\n$ git commit -m \"New commit\"\ngit reset --soft HEAD~1 명령어로 .git 저장소 변경사항을 준비영역으로 가져온다.\n$ git reset --soft HEAD~1\n$ git status\n\nOn branch main\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n        modified:   index.md\n\n2.6.4 마지막 커밋 완전히 취소하기\ngit add, git commit 명령어로 로컬 .git 저장소에 변경사항을 기록한다.\n$ echo \"New Content\" &gt; index.md\n$ git add index.md\n$ git commit -m \"New commit\"\ngit reset --hard HEAD~1 명령어로 .git 저장소 변경사항 뿐만 아니라 파일 변경상태도 원상태로 돌아간다.\n$ git reset --hard HEAD~1\n$ git status\nOn branch main\nnothing to commit, working tree clean\n$ ls\nindex.md"
  },
  {
    "objectID": "git_github.html#복원",
    "href": "git_github.html#복원",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.7 복원",
    "text": "2.7 복원\nindex.md라는 이름의 파일은 이미 몇 번의 커밋이 이루어진 이력이 있다고 가정하자. 이전 버전의 파일을 복원하고, 수정하고, 그리고 커밋하는 방법을 살펴보자.\n\n2.7.1 파일 이전 버전 확인\ngit log 명령어를 사용해서 파일 커밋 이력을 확인한다.\n$ git log -- index.md\n\ncommit 0f6f25f (HEAD -&gt; main)\nAuthor: User &lt;user@email.com&gt;\nDate:   Tue Jun 1 12:00:00 2023\n\n    Change index.md\n\ncommit b0d13fe\nAuthor: User &lt;user@email.com&gt;\nDate:   Mon May 31 12:00:00 2023\n\n    Add index.md\n\n2.7.2 이전 버전 파일 복원\nb0d13fe 커밋의 index.md 파일을 현재 디렉토리에 복원한다.\n$ git checkout b0d13fe -- index.md\n$ ls\nindex.md  otherfile.txt\n$ cat index.md\n# Index\nThis is the content of the index.md file.\n\n2.7.3 파일 수정 및 커밋하기\n파일을 수정한 후 git status로 확인한다.\n$ echo \"Modified Content\" &gt; index.md\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   index.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git add index.md\n$ git commit -m \"Modified index.md\"\ngit log를 통해 새로운 커밋이 기록되었는지 확인한다.\n$ git log -- index.md\n\ncommit 2a6d8fc (HEAD -&gt; main)\nAuthor: User &lt;user@email.com&gt;\nDate:   Wed Jun 2 12:00:00 2023\n\n    Modified index.md\n\ncommit 0f6f25f\nAuthor: User &lt;user@email.com&gt;\nDate:   Tue Jun 1 12:00:00 2023\n\n    Change index.md\n\ncommit b0d13fe\nAuthor: User &lt;user@email.com&gt;\nDate:   Mon May 31 12:00:00 2023\n\n    Add index.md\n\n\n\n\n\n\n저장소 청수\n\n\n\ngit clean -n 명령어를 통해서 git 추적되지 않는 파일을 확인할 수 있다.\n$ git clean -n\ngit clean -f 명령은 git 추적이 되지 않는 파일을 삭제시킨다.\n$ git clean -f"
  },
  {
    "objectID": "git_github.html#git-branch",
    "href": "git_github.html#git-branch",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.8 git branch\n",
    "text": "2.8 git branch"
  },
  {
    "objectID": "git_github.html#git-pullpush",
    "href": "git_github.html#git-pullpush",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.9 git pull/push\n",
    "text": "2.9 git pull/push"
  },
  {
    "objectID": "git_github.html#git-config",
    "href": "git_github.html#git-config",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.10 git config\n",
    "text": "2.10 git config"
  },
  {
    "objectID": "git_github.html#git-branchmerge",
    "href": "git_github.html#git-branchmerge",
    "title": "챗GPT 데이터 사이언스",
    "section": "\n2.8 git branch/merge\n",
    "text": "2.8 git branch/merge"
  }
]